---
output: 
  pdf_document:
    citation_package: none
    fig_caption: true
    keep_tex: true
documentclass: article
classoption: 10pt,letterpaper
geometry: top=0.85in,left=2.75in,footskip=0.75in
date: ""
header-includes:
   - \usepackage[nomarkers, nolists, figuresonly]{endfloat}
   - \usepackage{amsmath,amssymb}
   - \usepackage{changepage}
   - \usepackage{textcomp,marvosym}
   - \usepackage{cite}
   - \usepackage{nameref,hyperref}
   - \usepackage[right]{lineno}
   - \usepackage{microtype}
   - \DisableLigatures[f]{encoding = *, family = * }
   - \usepackage[table]{xcolor}
   - \usepackage{array}
   - \newcolumntype{+}{!{\vrule width 2pt}}
   - \newlength\savedwidth
   - \newcommand\thickcline[1]{ \noalign{\global\savedwidth\arrayrulewidth\global\arrayrulewidth 2pt} \cline{#1}  \noalign{\vskip\arrayrulewidth} \noalign{\global\arrayrulewidth\savedwidth}}
   - \newcommand\thickhline{\noalign{\global\savedwidth\arrayrulewidth\global\arrayrulewidth 2pt} \hline \noalign{\global\arrayrulewidth\savedwidth}}
   - \usepackage{setspace}
   - \doublespacing
   - \raggedright
   - \setlength{\parindent}{0.5cm}
   - \textwidth 5.25in 
   - \textheight 8.75in
   - \usepackage[aboveskip=1pt,labelfont=bf,labelsep=period,justification=raggedright,singlelinecheck=off]{caption}
   - \renewcommand{\figurename}{Fig}
   - \makeatletter
   - \renewcommand{\@biblabel}[1]{\quad#1.}
   - \makeatother
   - \input{GrandMacros.tex}
   - \usepackage{booktabs}
   - \renewcommand{\familydefault}{cmss}
   - \usepackage{lastpage,fancyhdr,graphicx}
   - \usepackage{epstopdf}
   - \pagestyle{myheadings}
   - \pagestyle{fancy}
   - \fancyhf{}
   - \setlength{\headheight}{27.023pt}
   - \rfoot{\thepage/\pageref{LastPage}}
   - \renewcommand{\footrule}{\hrule height 2pt \vspace{2mm}}
   - \fancyheadoffset[L]{2.25in}
   - \fancyfootoffset[L]{2.25in}
bibliography: feature-weighted-ensembles.bib
---

   <!-- - \lhead{\includegraphics[width=2.0in]{PLOS-submission-eps-converted-to.pdf}} -->
   <!-- - \lfoot{\sf PLOS} -->

```{r init, include = FALSE}
library(plyr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(grid)
library(awes)
library(mosaic)
library(gridExtra)
library(cowplot)
library(nlme)
library(multcomp)
```

\vspace*{0.2in}

\begin{flushleft}
{\Large
\textbf\newline{Prediction of infectious disease epidemics via weighted density ensembles} % Please use "sentence case" for title and headings (capitalize only the first word in a title (or heading), the first word in a subtitle (or subheading), and any proper nouns).
}
\newline
% Insert author names, affiliations and corresponding author email (do not include titles, positions, or degrees).
\\
Evan L. Ray\textsuperscript{*},
Nicholas G. Reich
\\
\bigskip
Department of Biostatistics and Epidemiology, University of Massachusetts, Amherst, MA, USA
\\

\bigskip

% Use the asterisk to denote corresponding authorship and provide email address in note below.
* elray@umass.edu

\end{flushleft}

# Abstract

Accurate and reliable predictions of infectious disease dynamics can be valuable to public health organizations that plan interventions to decrease or prevent disease transmission.
A great variety of models have been developed for this task, using different model structures, covariates, and targets for prediction.
Experience has shown that the performance of these models varies; some tend to do better or worse in different seasons or at different points within a season. 
Ensemble methods combine multiple models to obtain a single prediction that leverages the strengths of each model.
We considered a range of ensemble methods that each form a predictive density for a target of interest as a weighted sum of the predictive densities from component models. 
In the simplest case, equal weight is assigned to each component model; in the most complex case, the weights vary with the region, prediction target, week of the season when the predictions are made, a measure of component model uncertainty, and recent observations of disease incidence. 
We applied these methods to predict measures of influenza season timing and severity in the United States, both at the national and regional levels, using three component models. 
We trained the models on retrospective predictions from 14 seasons (1997/1998 - 2010/2011) and evaluated each model's prospective, out-of-sample performance in the five subsequent influenza seasons.
In this test phase, the ensemble methods showed overall performance that was similar to the best of the component models, but offered more consistent performance across seasons than the component models. 
Ensemble methods offer the potential to deliver more reliable predictions to public health decision makers.

# Author Summary

Public health agencies such as the Centers for Disease Control would like to have as much information as possible when planning interventions intended to reduce and prevent the spread of infectious disease.  For instance, accurate and reliable predictions of the timing and severity of the influenza season could help with planning how many influenza vaccine doses to produce and by what date they will be needed.  Many different mathematical and statistical models have been proposed to model influenza and other infectious diseases, and these models have different strengths and weaknesses.  In particular, one or another of these model specifications is often better than the others in different seasons, at different times within the season, and for different prediction targets (such as different measures of the timing or severity of the influenza season).  In this article, we explore ensemble methods that combine predictions from multiple “component” models.  We find that these ensemble methods do about as well as the best of the component models in terms of aggregate performance across multiple seasons, but that the ensemble methods have more consistent performance across different seasons.  This improved consistency is valuable for planners who need predictions that can be trusted under all circumstances.

\linenumbers

# Introduction

The practice of combining predictions from different models has been used for decades by climatologists and geophysical scientists. 
These methods have subsequently been adapted and extended by statisticians and computer scientists in diverse areas of scientific inquiry. 
In recent years, these "ensemble" forecasting approaches frequently have been among the top methods used in prediction challenges across a wide range of applications.

Ensembles are a natural choice for noisy, complex, and interdependent systems that evolve over time. 
In these settings, no one model is likely to be able to capture and predict the full set of complex relationships that drive future observations from a particular system of interest. 
Instead "specialist" or "component" models can be relied on to capture distinct features or signals from a system and, when combined, represent a nearly complete range of possible outcomes.
In this work, we develop and compare a collection of ensemble methods for combining predictive densities. 
This enables us to quantify the improvement in predictions achieved by using ensemble methods with varying levels of complexity.

To illustrate these ensemble methods, we present time-series forecasts for infectious disease, specifically for influenza in the United States.
The international significance of emerging epidemic threats in recent decades has highlighted the importance of understanding and being able to predict infectious disease dynamics.
With the revolution in science driven by the promise of "big" and real-time data, there is an increased focus on and hope for using statistics to inform public health policy and decision-making in ways that could mitigate the impact of future outbreaks. 
Some of the largest public health agencies in the world, including the US Centers for Disease Control and Prevention (CDC) have openly endorsed using models to inform decision making, saying "with models, decision-makers can look to the future with confidence in their ability to respond to outbreaks and public health emergencies" \cite{cdc-decisions-2016}.

Development of the methods presented in this manuscript was motivated by the observation that certain prediction models for infectious disease consistently performed better than other models at certain times of year. 
We observed in previous research that early in the influenza season, simple models of historical incidence often outperformed more standard time-series prediction models such as a seasonal auto-regressive integrated moving average (SARIMA) model \cite{ReichLabGitHubDiseasePredWithKCDEPackage}. 
However, in the middle of the season, the time-series models showed improved accuracy. 
We set out to determine whether ensemble methods could use this information about past model performance to improve predictions.

A large number of ensemble methods have been developed for a diverse array of tasks including regression, classification, and density estimation.  These methods are broadly similar in that they combine results from multiple component models.  However, details differ between ensemble methods.  We suggest Polikar \cite{polikar2006ensemble} for a review of ensemble methods; many of these are also discussed in detail in Hastie \etal \cite{Hastie2011}.

While there are many different methods for combining models, all ensemble models discussed in this paper use an approach called stacking. 
In this approach, each of the component models is trained separately in a first stage, and cross-validated measures of performance of those component models are obtained. 
Then, in a second stage, a stacking model is trained using the cross-validated performance measures to learn how to optimally combine predictive densities from the component models.
The specific implementations of stacking that we use obtain the final predictive density as a weighted sum of the component predictive densities, where the weights may depend on covariates.
We refer to this approach generally as a ''weighted density ensemble'' approach to prediction.
Several variations on this strategy have been explored in the literature previously \cite{smyth1999stackingDensityEstimators,  rigollet2007linearconvexaggregationdensity, ganti2011cake}.  However, other ensemble methods for density estimation have also been developed.  For example, Rosset and Segal \cite{rosset2002boosting} develop a boosting method in which the component models are estimated sequentially, with results from earlier models affecting estimation of later models.

In structured prediction settings such as time series forecasting, ensemble methods may benefit from taking advantage of the data structure.  For example, it may be the case that different models offer a better representation of the data at different points in time.  A common idea in these settings is to use model weights that change over time.  For instance, model weights may vary as a function of how well each model did in recent predictions \cite{herbster1998tracking} or by using a more formal graphical structure such as a hidden Markov model to track which component model is most likely to have generated new observations as they arise over time \cite{yamanishi2007dynamicmodelselection, cortes2014ensembleStructuredPrediction}.  It is also possible to combine the component models with weights that depend on observed covariates or features \cite{Sill2009}.  For example, in an ensemble for a user recommendation system, Jahrer \etal \cite{jahrer2010Netflix} allowed model weights to depend on a variety of features including the time that a user submitted a rating.

Using component models that generate predictive densities for outcomes of interest, we have implemented a series of ensembles using different methods for choosing the weights for each model. 
Specifically, we compare three different approaches. 
The first approach simply takes an equally weighted average of all models.
The second approach estimates constant but not necessarily equal weights for each model.
The third approach is a novel method for determining model weights based on features of the system at the time predictions are made.
The overarching goal of this study is to create a systematic comparison between ensemble methods to study the benefits of increasing complexity in ensemble weighting schemes.

We are aware of one previous article that has developed ensemble methods for infectious disease prediction.  Yamana \etal \cite{Yamana2016} developed a model stacking framework that is similar to the second approach outlined above using a constant weight for each component model.  The present article is differentiated from that work in that we explore and compare a range of more flexible ensemble methods where the weights depend on observed features.

This paper presents a novel ensemble method that determines optimal model combinations based on (a) observed data at the time predictions are made and (b) aspects of the predictive distributions obtained from the component models. 
We refer to models built using this approach as "feature-weighted" ensembles.
This approach fuses aspects of different ensemble methods: it uses model stacking \cite{Wolpert1992} and estimates model weights based on features of the system \cite{Sill2009} using gradient tree boosting \cite{friedman2001greedy}.

Using seasonal influenza outbreaks in the US health regions as a case-study, we developed and applied our ensemble models to predict several attributes of the influenza season at each week during the season.
By illustrating the utility of these approaches to ensemble forecasting in a setting with complex population dynamics, this work highlights the importance of continued innovation in ensemble methodology.

# Methods

This paper presents a comparison of methods for determining weights for weighted density ensembles, applied to forecasting specific features of influenza seasons in the US. 
First, we present a description of the influenza data we use in our application and the prediction targets.
Next, we discuss the three component models utilized by the ensemble framework.
We then turn to the ensemble framework itself, describing the different ensemble model specifications used.

## Data and prediction targets

We obtained publicly available data on seasonal influenza activity in the United States between 1997 and 2016 from the US Centers for Disease Control and Prevention (CDC) (Fig \ref{fig:raw-data}).
For each of the 10 Health and Human Services regions in the country in addition to the nation as a whole, the CDC calculates and publishes each week a measure called the weighted influenza-like illness (wILI) index.
The wILI for a particular region is calculated as the average proportion of doctor visits with influenza-like illness for each state in the region, weighted by state population. 
During the CDC-defined influenza season (between Morbidity and Mortality Weekly Report week 40 of one year and 20 of the next year), the CDC publishes updated influenza data on a weekly basis. 
This includes "current" wILI data from two weeks prior to the reporting date, as well as updates to previously reported numbers as new data becomes available. 
For this analysis, we use only the final reported wILI measures to train and predict from our models.
In the early seasons, data were not recorded during the off-season.  Additionally, there were 52 observations in which the reported wILI was zero; these generally occurred near the off-season in early years, and occurred in weeks when only small numbers of health care providers submitted reports to the CDC.  We treated these reported zeros as missing data throughout the analysis.

The CDC defines the influenza season onset as the first of three consecutive weeks of the season for which wILI is greater than or equal to a threshold that is specific to the region and season. 
This threshold is the mean percent of patient visits where the patient had ILI during low incidence weeks for that region in the past three seasons, plus two standard deviations \cite{cdc2016}.
The CDC provides historical threshold values for each region going back to the 2007/2008 season \cite{cdc2016-baselines}. 
Additionally, we define two other metrics specific to a region-season.
The peak incidence is the maximum observed wILI measured in a season. 
The peak week is the week at which the maximum wILI for the season is observed.

Each predictive distribution was represented by probabilities assigned to bins associated with different possible outcomes.
For onset week, the bins are represented by integer values for each possible season week plus a bin for "no onset". 
For peak week, the bins are represented by integer values for each possible season week.
For peak incidence, the bins capture incidence rounded to a single decimal place, with a single bin to capture all incidence over $12.95$. 
Formally, the incidence bins are as follows: [0, 0.05), [0.05, 0.15), ..., [12.95, 12.95), [12.95, $\infty$).
These bins were used in the 2016-2017 influenza prediction contest run by the CDC \cite{cdc2016-contest-guidelines}.

We measure the accuracy of predictive distributions using the log score.
The log score is a proper scoring rule \cite{Gneiting2007}, calculated in our setting as the natural log of the probability assigned to the bin containing the true observation.
Proper scoring rules are preferred for measuring the quality of predictive distributions because the expected score is optimized by the true probabilty distribution.
We note that for peak week, in some region-seasons the same peak incidence was achieved in multiple weeks (after rounding to one decimal place).
In those cases, we calculated the log score as the log of the sum of the probabilities assigned to those weeks; this is consistent with scoring procedures used in the 2016-2017 flu prediction contest run by the CDC \cite{cdc2016-contest-guidelines}.
However, the log score is not directly comparable with the score used by the CDC in the prediction contest.
The CDC calculates the score of a prediction as the log of the combined probability assigned to several bins surrounding the realized outcome; this has some benefits, but has the disadvantage that it is not a proper score.
We have opted to use the log score in this work because it is a proper score.

## Component models
We used three component models to generate probabilistic predictions of the three prediction targets. The first model was a seasonal average model that utilized kernel density estimation (KDE) to estimate a predictive distribution for each target. The second model utilized kernel conditional density estimation (KCDE) and copulas to create a joint predictive distribution for incidence in all remaining weeks of the season, conditional on recent observations of incidence \cite{ReichLabGitHubDiseasePredWithKCDEPackage}.  By calculating appropriate integrals of this joint distribution, we constructed predictive distributions for each of the seasonal targets.  The third model used a standard seasonal auto-regressive integrated moving average (SARIMA) implementation. All models were fit independently on data within each region.

### Kernel Density Estimation (KDE)
The simplest of the component models uses kernel density estimation \cite{silverman1986density} to estimate a distribution for each target based on observed values of that target in previous seasons within the region of interest.
We used Gaussian kernels and the default KDE settings from the `density` function in the `stats` package for R \cite{Rcore2015} to estimate the bandwidth parameter.
For the peak incidence target, we fit to log-transformed observations of historical peak incidence.
For the onset week prediction target, we estimated the probability of no onset as the proportion of region-seasons in all regions in the training phase where no week in the season met the criteria for being a season onset.

To create an empirical predictive distribution of size $N$ from a KDE fit based on a data vector $\by_{1:K}$ (for example, this might be the vector of peak week values from the $K$ training seasons), we first drew $N$ samples with replacement from $\by_{1:K}$, yielding a new vector $\tilde \by_{1:N}$.
We then drew a single psuedo-random deviate from each of $N$ truncated Gaussian distributions centered at $\tilde \by_{1:N}$ with the bandwidth estimated by the KDE algorithm.
The Gaussians we sampled from were truncated at the lower and upper bounds of possible values for the given prediction target.
Finally, we discretized the sampled values to the target-specific bins.
These sampled points then make up the empirical predictive distribution from a KDE model.
We set the sample size to $N = 10^5$.  In theory, this model assigns non-zero probability to every possible outcome; however, in a few cases the empirical predictive distribution resulting from this Monte Carlo sampling approach assigned probability zero to some of the bins.

It is important to note that the predictions from this model do not change as new data are observed over the course of the season.

### Kernel Conditional Density Estimation (KCDE)
We used kernel conditional density estimation and copulas to estimate a joint predictive distribution for flu incidence in each future week of the season, and then calculated predictive distributions for each target from that joint distribution \cite{ReichLabGitHubDiseasePredWithKCDEPackage}.
In our implementation, we first used KCDE to obtain separate predictive densities for flu incidence in each future week of the season.  Each of these predictive densities gives a conditional distribution for incidence at one future time point given recent observations of incidence and the current week of the season.  KCDE can be viewed as a distribution-based analogue of nearest-neighbors regression.  We then used a copula to model dependence among those individual predicitive densities, thereby obtaining a joint predicitive density, or a distribution of incidence trajectories in all future weeks.

To predict seasonal quantities (onset, peak timing, and peak incidence), we simulate $N = 10^5$ trajectories of disease incidence from this joint predictive distribution.
For each simulated incidence trajectory, we compute the onset week, peak week, and peak incidence.
We then aggregate these values to create predictive distributions for each target.
This procedure for obtaining predictive distributions for the targets of interest can be formally justified as an appropriate Monte Carlo integral of the joint predictive distribution for disease incidence in future weeks (see \cite{ReichLabGitHubDiseasePredWithKCDEPackage} for details).

### Seasonal auto-regressive integrated moving average (SARIMA)
We fit seasonal ARIMA models \cite{Box2015} to wILI observations transformed to be on the natural log scale.  We manually performed first-order seasonal differencing and used the stepwise procedure from the `auto.arima` function in the `forecast` package \cite{Hyndman2008} for R to select the specification of the auto-regressive and moving average terms.

Similar to KCDE, forecasts were obtained by sampling $N = 10^5$ trajectories of wILI values over the rest of the season (using the `simulate.Arima` function from the `forecast` package), and predictive distributions of the targets were computed from these sampled trajectories as described above.

### Component model training

We used data from 14 seasons (1997/1998 through 2010/2011) to train the models. 
Data from five seasons (2011/2012 through 2015/2016) were held out when fitting the models and used exclusively in the testing phase. 
To avoid overfitting our models, we made predictions for the test phase only once \cite{Hastie2011}.

Estimation of the ensemble models (discussed in the next subsection) requires cross-validated measures of performance of each of the component models in order to accurately gauge their relative performance.
For each region, we estimated the parameters of each component model 15 times: 14 fits were obtained excluding one training season at a time, and another fit used all of the training data.
For each fit obtained leaving one season out, we generated a set of three predictive distributions (one for each of the prediction targets) at each week in the held-out season.
We were not able to generate predictions from the SARIMA and KCDE models for some seasons in the training phase because those models used lagged observations from previous seasons that were missing in our data set.
The component model fits based on all of the training data were used to generate predictions for the test phase.


## Ensemble models

All of the ensemble models we consider in this article work by averaging predictions from the component models to obtain the ensemble prediction.
Additionally, these methods are stacked model ensembles because they use leave-one-season-out predictions from the independently estimated component models as inputs to estimate the model weights \cite{Wolpert1992}.
We begin our discussion of ensemble methods with a general overview, introducing a common set of notation and giving a broad outline of the ensemble models we will use in this article.
We then describe our proposed weighted density ensemble model specifications in more detail.

### Overview of ensemble models

A single set of notation can be used to describe all of the ensemble frameworks implemented here.
Let $f_m(y_t|\bx_t^{(m)})$ denote the predictive density from component model $m$ for the value of the scalar random variable $Y_t$ conditional on observed variables $\bx_t^{(m)}$.  Observations of disease incidence are reported weekly in our data set, so $t$ indexes the week of the season.  The variable $Y_t$ could for example represent the peak incidence for a given season and region; in our application to predicting seasonal quantities, the same outcome $y_t$ will be realized for all weeks within a given season.
In the context of time series predictions, the covariate vector $\bx_t^{(m)}$ may include time-varying covariates such as the week at which the prediction is made or lagged incidence.  The superscript $^{(m)}$ reflects the fact that each component model may use a different set of covariates.

The combined predictive density $f(y_t|\bx_t)$ for a particular target can be written as 
\begin{equation}
f(y_t|\bx_t) = \sum_{m = 1}^M \pi_m(\bx_t) f_m(y_t|\bx_t^{(m)}). \label{eqn:EnsembleModel} 
\end{equation}
In Equation \eqref{eqn:EnsembleModel} the $\pi_m$ are the model weights, which are allowed to vary as a function of observed features in $\bx_t$.  We define $\bx_t$ to be a vector of all observed quantities that are used by any of the component models or in calculating the model weights.  In order to guarantee that $f(y_t|\bx_t)$ is a probability distribution we require that $\sum_{m = 1}^M \pi_m(\bx_t) = 1$ for all $\bx_t$.
Fig \ref{fig:stacking-concept} illustrates the concept of stacking the predictive densities for each component model.

In the following subsection, we propose a framework for estimating _feature-dependent weights_ for a stacked ensemble model. 
By _feature-dependent_ we mean that the weights associated with different component models are driven by observed features or covariates.
Although we illustrate the method in the context of time-series predictions, the method could be used in any setting where we wish to combine distribution estimates from multiple models.
Features could include observed data from the system being predicted (such as recent wILI measurements or the time of year at which predictions are being made), observed data from outside the system (for example, recent weather observations), or features of the predictions themselves (e.g. summaries of the predictive distributions from the component models, such as a measure of spread in the distribution, or the time until a predicted peak).
Based on exploration of training phase data and _a priori_ knowledge of the disease system, we chose three features of the system to illustrate the proposed "feature-weighting" methodology: 
week of season, 
component model uncertainty (defined as the minimum number of predictive distribution bins required to cover 90% probability), and 
wILI measurement at the time of prediction.
These features were chosen prior to and not changed after implementing test-phase predictions.

We used four distinct methodologies to define weights to use for the stacking models:

1. Equal Weights (\textbf{EW}): $\pi_m(\bx_t) = 1/M$. In this scenario, each model contributes the same weight for each target and for all values of $\bx_t$.

2. Constant model weights via degenerate EM (\textbf{CW}): $\pi_m(\bx_t) = c_m$, a constant where $\sum_{m=1}^M c_m = 1$ but the constants are not necessarily the same for each model. These weights are estimated using the degenerate estimation-maximization algorithm \cite{Lin2004}.  A separate set of weights is estimated for each region and prediction target.

3. Feature-weighted (\textbf{FW}): $\pi_m(\bx_t)$ depends on features including week of the season and model uncertainty for the KCDE and SARIMA models.  A separate set of weighting functions is estimated for each region and prediction target.

4. Feature-weighted with regularization: $\pi_m(\bx_t)$ depends on features, but with regularization discouraging the weights from taking extreme values or from varying too quickly as a function of $\bx_t$.  A separate set of weighting functions is estimated for each region and prediction target.  We fit three variations on this ensemble model, using different sets of features:
    a. (\textbf{FW-reg-w}) week of the season;
    b. (\textbf{FW-reg-wu}) week of the season and model uncertainty for the KCDE and SARIMA models;
    c. (\textbf{FW-reg-wui}) week of the season, model uncertainty for the KCDE and SARIMA models, and incidence (wILI) in the most recent week.

All in all, this leads to 6 ensemble models, summarized in Table \ref{tbl:EnsembleModelSummaryTable}.  The first three of these models (\textbf{EW}, \textbf{CW}, and \textbf{FW}) can be viewed as variations on \textbf{FW-reg-wu} if we vary the amount and type of regularization imposed on the \textbf{FW-reg-wu} model.  Thus, comparisons among these four models will enable us to explore the benefits of allowing the model weights to depend on covariates while imposing an appropriate amount of rigidity on the model weight functions $\pi_m(\bx_t)$.  We will discuss the regularization strategies used in \textbf{FW-reg-wu} further in the next subsection.  Meanwhile, comparisons among the \textbf{FW-reg-w}, \textbf{FW-reg-wu}, and \textbf{FW-reg-wui} models will allow us to explore the relative contributions to predictive performance that can be achieved by allowing the model weights to depend on different features.

\begin{table}[!ht]
\centering
\caption{\label{tbl:EnsembleModelSummaryTable}Summary of ensemble methods and what the model weights depend on.}
\begin{tabular}{rcccccc}
\toprule
         & \multicolumn{6}{c}{Component Model Weights Vary with...} \\
\cline{2-7}
  &   & Prediction & Week of & SARIMA & KCDE & Current \\ 
Model & Region & Target & Season & Uncertainty & Uncertainty & wILI \\ 
  \hline
EW         &   &   &   &   &   &   \\
CW        & X & X &   &   &   &   \\
FW         & X & X & X & X & X &   \\
FW-reg-w   & X & X & X &   &   &   \\
FW-reg-wu  & X & X & X & X & X &   \\
FW-reg-wui & X & X & X & X & X & X \\
\bottomrule
\end{tabular}
\end{table}

As discussed above, leave-one-season-out prediction results from the three component models are inputs to the ensemble estimation routines.
During ensemble estimation, we dropped any training set time points for which cross-validated predictions from all three component models were not available.
After the training phase, each of the six ensemble models, along with the three component models, are used to generate predictions in every season-week of each of the five testing seasons, assuming perfect reporting. 
These predictions are then used to evaluate the prospective predictive performance of each of the ensemble methods. 
In total, we evaluate 9 models in 11 regions over 5 years and 3 targets of interest. 

## Feature-weighted stacking framework

In this section we introduce the particular specification of the parameter weight functions $\pi_m(\bx_t)$ that we use for the \textbf{FW}, \textbf{FW-reg-w}, \textbf{FW-reg-wu}, and \textbf{FW-reg-wui} models and discuss estimation.

In order to ensure that the the $\pi_m$ are non-negative and sum to 1 for all values of $\bx_t$, we parameterize them in terms of the softmax transformation of real-valued latent functions $\rho_m$
\begin{equation}
\pi_{m}(\bx_t) = \frac{\exp\{\rho_m(\bx_t)\}}{\sum_{m' = 1}^M \exp\{\rho_{m'}(\bx_t)\}}.  \label{eqn:PiSoftmaxRho} 
\end{equation}
For a pair of models $l, m \in \{1, ..., M\}$, $\rho_l(\bx_t) > \rho_m(\bx_t)$ indicates that model $l$ has more weight than model $m$ for predictions at the given value of $\bx_t$.
The functions $\rho_m(\bx_t)$ could be parameterized and estimated using many different techniques, such as a linear specification in the features, splines, or so on.  We chose to estimate the functions $\rho_m(\bx)$ using gradient tree boosting.

Gradient tree boosting uses a forward stagewise additive modeling algorithm to iteratively and incrementally construct a series of regression trees that, when added together, create a function designed to minimize a given loss function. 
In our application, the algorithm builds up the $\rho_m(\bx_t)$ that minimize the negative log-score of the stacked predictions $f(y_t|\bx_t)$ across all times $t$:
\begin{align}
L\{\brho(\bx_t)\} &= - \sum_{t} \log\{f(y_t|\bx_t)\} \nonumber \\
&= - \sum_{t} \log\left[\sum_{m = 1}^M \frac{\exp\{\rho_m(\bx_t)\}}{\sum_{m' = 1}^M \exp\{\rho_{m'}(\bx_t)\}}f_m(y_t|\bx_t^{(m)})\right], \label{eqn:logloss}
\end{align}
where $f_m(y_t|\bx_t^{(m)})$ is the cross-validated predictive density from the $m$th model evaluated at the realized outcome $y_t$.

Specifically, we define a single tree as
\begin{equation}
T(\bx_t; \btheta) = \sum_{j=1}^J \gamma_j I_{R_j(\bpsi)}(\bx_t),
\end{equation}
where the $R_j(\bpsi)$ are a set of disjoint regions that comprise a partition of the space $\mathcal{X}$ of feature values $\bx_t$, and $I$ is the indicator function taking the value $1$ if $\bx_t \in R_j(\bpsi)$ and $0$ otherwise. The parameters $\btheta = (\bpsi, \bgamma)$ for the tree are the split points $\bpsi$ partitioning $\mathcal{X}$ into the regions $R_j(\bpsi)$ and the regression constants $\bgamma$ associated with each region.
The function $\rho_m(\bx_t)$ is obtained as the sum of $B$ trees:
\begin{equation}
\rho_m(\bx_t; \Theta_m) = \sum_{b=1}^B T(\bx_t; \btheta_{m, b}).
\end{equation}

In each iteration $b$ of the boosting process, we estimate $M$ new regression trees, one for each component model.  These trees are estimated so as to minimize a local approximation to the loss function around the weight functions that were obtained after the previous boosting iteration.  Our approach builds on the `xgb.train` function in the `xgboost` package for `R` to perform this estimation \cite{xgboost}.  The functionality in that package assumes that the loss function is convex, and optimizes a quadratic approximation to the loss in each boosting iteration.  The loss function in Equation \eqref{eqn:logloss} is not guaranteed to be convex, so a direct application of this optimization method fails in our setting.  We have modified the implementation in the `xgboost` package to use a gradient descent step in cases where the loss is locally nonconvex (concave or indeterminate).

Gradient tree boosting is appealing as a method for estimating the functions $\rho_m$ because it offers a great deal of flexibility in how the weights can vary as a function of the features $\bx_t$.  On the other hand, this flexibility can lead to overfitting the training data.  In order to limit the chances of overfitting, we have explored the use of three regularization parameters:

1. The number of boosting iterations $B$.  As $B$ increases, more extreme weights (close to 0 or 1) and more rapid changes in the weights as $\bx$ varies are possible.

2. An $L_1$ penalty on the number of tree leaves, $J$.  A large penalty encourages the regression trees to have fewer leaves, so that there is less flexibility for the model weights to vary as a function of $\bx_t$.

3. An $L_1$ penalty on the regression constants $\gamma_j$.  A large penalty encourages these constants to be small, so that the overall model weights change less in each boosting iteration.

We selected values for these regularization parameters using a grid search optimizing leave-one-season-out cross-validated model performance.

<!-- To prevent the stacking model from overfitting the training data, we estimate the model parameters by optimizing a penalized loss function where the penalty encourages the splines to be smooth.  The underlying unpenalized loss function is a measure of the quality of the final predictive distribution $f_t(y_t)$, obtained by cross-validation.  Because model performance will be evaluated using log scores, we will use negative cross-validated log scores as the loss function during parameter estimation: -->
<!-- The final predictions are obtained as a linear combination of the predictions from these component models.  The model weights depend on the week of the season in which the predictions are made.  We represent these weights as the softmax transformation of latent functions rho_ilt(season week) where i = 1, ..., 3 indexes the component model, l = 1, ..., 11 indexes the location (national or region 1 through 10), and t = 1, ..., 7 indexes the prediction target.  We estimate those latent functions rho_ilt via gradient tree boosting, optimizing leave-one-season-out crossvalidated log scores (using the definition of log scores specified for this competition). -->


<!-- Two feature-weighted (changing by season_week only, estimated separately by metric and region) -->
<!--   3a. season_week -->
<!--   3b. season_week*model_confidence -->
<!-- Three feature-weighted with regularization parameters chosen via cross-validation: -->
<!--   4a. season_week -->
<!--   4b. season_week*model_confidence -->
<!--   4c. season_week*model_confidence*lag1_ili -->

<!-- X = (week of season, model confidence, recent incidence) -->

<!-- 8 methods (1 equal-bin-weight + 3 component + 4 ensemble) / 3-7 metrics / 5 test seasons -->




## Software and code

We used R version 3.2.2 (2015-08-14) for all analyses \cite{Rcore2015}.
All data and code used for this analysis is freely available in an R package online at https://github.com/reichlab/adaptively-weighted-ensemble and may be installed in R directly.
Predictions generated in real-time with early development versions of this model during the 2016/2017 influenza season may be viewed at https://reichlab.io/flusight/.
To maximize reproducibility of our work, we have set seeds prior to running code that relies on stochastic simulations using the `rstream` package \cite{Leydold2015}.
Additionally, the manuscript itself was dynamically generated using RMarkdown.

# Results

To evaluate overall model performance, we computed log scores for all predictions made by each model across all regions and test phase seasons.  We also examined results for predictions made before the peak week (for predictions of peak timing or peak incidence) or the season onset (for predicitons of onset timing) within each of the test phase seasons.

### Feature-weighted ensemble model weights reflect trends in component model log scores

Fig \ref{fig:example-weights} displays variation in leave-one-season-out log scores from the three component models over the course of the training phase seasons, along with the corresponding model weight estimates from the \textbf{CW} and \textbf{FW-reg-w} models.  Performance of the \textbf{SARIMA} and \textbf{KCDE} models is similar, with mean log scores from those models starting out near or slightly below the mean performance of \textbf{KDE}, but with performance improving as more data become available.  Near the beginning of some seasons, predictions from the \textbf{SARIMA} model are quite a bit worse than predictions from the other two component models.  Supplemental Fig 1 illustrates that these patterns are consistent across the other regions.  Supplemental Fig 2 shows that performance of the component models also varies with the model's uncertainty as measured by the number of bins required to cover 90\% in the predictive distribution, and Supplemental Fig 3 shows that performance varies with the observed wILI in the week when predictions are made.

The model weights assigned by the feature weighted ensemble models generally track these trends in relative model performance (Figs \ref{fig:example-weights}, \ref{fig:FWregwuModelWeights}).  For all three targets, at the national level the weight assigned to the \textbf{SARIMA} model increases and the weight assigned to \textbf{KDE} decreases as the season progresses.  However, the magnitude of shifts in model weights as the weighting features vary is different for the three prediction targets.

### Best models have similar aggregate performance

Aggregating across all combinations of region, season, and week of the season in the test phase, most of the models had similar performance (Fig \ref{fig:test_phase_log_score_boxplot}).  The most important exception to this is the \textbf{KDE} model, which achieved consistently lower log scores than the other methods, including several cases where the Monte Carlo sampling procedure we used to approximate the predictive distribution assigned probability 0 to the true peak incidence bin (there was one such case for the \textbf{KCDE} model).  The low performance of the \textbf{KDE} model pulled the log scores for the \textbf{EW} method slightly below the other methods, and resulted in some outlying cases where the unregularized \textbf{FW-wu} method performed poorly for predicting peak incidence.  However, aggregated performance of the \textbf{KCDE}, \textbf{SARIMA}, \textbf{CW}, and variations on the \textbf{FW} models was quite similar in most cases.  A linear mixed effects model was not able to distinguish any statistically significant differences in mean performance of these methods (Supplemental Figs 4 and 5).

### Ensembles show stable performance across seasons for early-season predictions

Although the aggregate performance of these models is quite similar, some differences between the methods begin to emerge when we examine performance in more detail.  Predictions made before the season peak (for predictions of peak incidence or peak timing) or before the season onset (for predictions of season onset timing) are the most relevant to decision makers using the predictions as inputs to set public policy.  It is important that these predictions be of consistent quality in all seasons, whether the seasonal dynamics follow historic seasonal trends or diverge from those common patterns.  We evaluated the relative performance of predictions from each model that were generated before the onset or peak week in each test season (Fig \ref{fig:test_phase_log_scores_heatmap}).

In all test phase seasons and for all prediction targets, the worst performing model is always one of the three component models (\textbf{KDE}, \textbf{KCDE}, or \textbf{SARIMA}).  Furthermore, each of the component models outperforms the other two for at least one combination of season and prediction target.  Within each season, the component models are often among either the best-performing or the worst-performing models.  For example, the \textbf{SARIMA} model ranks first for predictions of peak timing in four out of five seasons and last in the fifth season, but ranks last for predictions of peak incidence in four out of five seasons and first in the remaining season.  Similar trends, though slightly less extreme, also hold for \textbf{KDE} and \textbf{KCDE}.

The ensemble methods have more stable performance across the test phase seasons.  Only \textbf{FW-reg-w} was among the top half of models in all seasons for predictions of onset timing; only \textbf{EW} and \textbf{FW-reg-w} were among the top half of models in all seasons for predictions of peak timing; and only \textbf{FW-reg-wu} and \textbf{FW-reg-wui} were among the top half of models in all seasons for predictions of peak incidence (Fig 5)

Model consistency can also be measured with the minimum of the log scores achieved across the test phase seasons.  Here again the ensemble methods outperform the component models.  In particular, worst-case performance of the \textbf{EW} and regularized \textbf{FW} methods is in the top half of all methods for all three prediction targets (Fig 5).

For example, consider predictions of peak timing, which could be used to plan the deployment of medical resources \cite{cdc-decisions-2016}.  Among the component models we considered, \textbf{SARIMA} had the highest mean log score across the test phase, and was the best model in four out of five test-phase seasons.  However, it had the worst performance of all models we considered in the 2015/2016 season.  The \textbf{EW} and \textbf{FW-reg-w} ensembles achieved only slightly lower average log scores than \textbf{SARIMA} overall, were among the best-performing methods in all five test seasons, and assigned an average of about 60 to 70 percent more probability to the eventually realized peak week than \textbf{SARIMA} in predictions made during the season that \textbf{SARIMA} struggled.

### Regularization improves feature-weighted ensemble models

The regularization of feature-weighted ensembles improved early-season prediction accuracy for all three metrics. 
Specifically, a comparison of average log-scores for the \textbf{FW-wu} and \textbf{FW-reg-wu} models show consistent improvement in the model that used regularization to create smoother functions of model weights as a function of season week and model uncertainty. 
Only once out of 15 combinations of target and test-season (onset timing in the 2015/2016 season) did \textbf{FW-wu} outperform its regularized counterpart (Fig 5). 


```{r raw_data_plot, echo=FALSE, fig.height=4, fig.cap="\\label{fig:raw-data}Plot of influenza data.  The full data include observations aggregated to the national level and for 10 smaller regions.  Here we plot only the data at the national level and in two of the smaller regions; data for the other regions are qualitatively similar.  Missing data are indicated with vertical blue bars.  The vertical red dashed lines indicate the cutoff time between the training and testing phases; 5 seasons of data were held out for testing."}
flu_data$region[flu_data$region == "X"] <- "National"
flu_data$region <- factor(flu_data$region,
  levels = c("National", paste0("Region ", 1:10)))

regions_to_plot <- c("National", "Region 1", "Region 7")
#regions_to_plot <- c("National", paste0("Region ", 1:10))
  
train_cutoff_ind <- min(which(flu_data$season == "2011/2012"))
train_cutoff_time <- flu_data$time[train_cutoff_ind]
train_cutoffs <- data.frame(
  region = regions_to_plot,
  train_cutoff_time = as.numeric(as.Date(train_cutoff_time))
)

ggplot() +
  geom_line(aes(x = as.Date(time), y = weighted_ili),
    data = flu_data[flu_data$region %in% regions_to_plot & flu_data$season %in% paste0(1997:2015, "/", 1998:2016), ]) +
  geom_vline(aes(xintercept = as.numeric(as.Date(time))),
    colour = "blue",
    data = flu_data[is.na(flu_data$weighted_ili) & flu_data$region %in% regions_to_plot & flu_data$season %in% paste0(1997:2015, "/", 1998:2016), ]) +
  geom_vline(aes(xintercept = train_cutoff_time),
    colour = "red",
    linetype = 2,
    data = train_cutoffs) +
  facet_wrap(~ region, ncol = 1) +
  scale_x_date() +
  xlab("Time") +
  ylab("Weighted Proportion of Doctor's Office Visits\nwith Influenza-like Illness\n") +
#  ggtitle("Influenza Data by Region")
  theme_bw(base_size = 11)
```

<!--#### Fig: 9 panel grid (3 component models x 3 metrics) showing a solid line for each region that represents the average log score across all seasons \label{fig:log-scores}-->

```{r stacking-concept, echo=FALSE, fig.height=3, fig.width=9, fig.keep='last', warning=FALSE, message=FALSE, fig.cap="\\label{fig:stacking-concept}Conceptual diagram of how the stacking models operate on probabilistic predictive distributions. The distributions illustrated here have density bins of 1 wILI unit, which differs from those used in the manuscript for illustrative purposes only. Panel A shows the predictive distributions from three component models. Panel B shows scaled versions of the distributions from A, after being multiplied by model weights. In Panel C, the scaled distributions are literally stacked to create the final ensemble predictive distribution."}
awes_path <- find.package("awes")

kde_full <- readRDS(file.path(awes_path,
  "estimation/loso-predictions/kde-National-2005-2006-loso-predictions.rds"))
kcde_full <- readRDS(file.path(awes_path,
  "estimation/loso-predictions/kcde-National-2005-2006-loso-predictions.rds"))
sarima_full <- readRDS(file.path(awes_path,
  "estimation/loso-predictions/sarima-National-2005-2006-loso-predictions.rds"))

## get indices
tmp_week <- 20
idx_kde <- which(kde_full$analysis_time_season_week==tmp_week)
idx_kcde <- which(kcde_full$analysis_time_season_week==tmp_week)
idx_sarima <- which(sarima_full$analysis_time_season_week==tmp_week)

kde_dens <- kde_full %>% 
    filter(analysis_time_season_week == tmp_week) %>%
    dplyr::select(starts_with("peak_inc_bin")) %>%
    as.numeric(.)

kcde_dens <- kcde_full %>% 
    filter(analysis_time_season_week == tmp_week) %>%
    dplyr::select(starts_with("peak_inc_bin")) %>%
    as.numeric(.)

sarima_dens <- sarima_full %>% 
    filter(analysis_time_season_week == tmp_week) %>%
    dplyr::select(starts_with("peak_inc_bin")) %>%
    as.numeric(.)

weights <- data_frame(
    mdl = factor(c("KCDE", "KDE", "SARIMA"), levels=c("KCDE", "KDE", "SARIMA")),
    weight = c(.5, .2, .3),
    x = 9,
    y=.4)

pred_dens <- data_frame(
    inc_bin = seq(0,13, .1),
    KDE = exp(kde_dens), 
    KCDE = exp(kcde_dens), 
    SARIMA = exp(sarima_dens)) %>%
    gather(
        key = mdl,
        value = probability,
        -inc_bin) %>%
    ## aggregate bins
    mutate(inc_bin = ceiling(inc_bin)) %>%
    group_by(mdl, inc_bin) %>%
    summarize(probability = sum(probability)) %>%
    left_join(weights) %>% ungroup() %>%
    mutate(mdl = factor(mdl, levels=c("KCDE", "KDE", "SARIMA")))

## make the base plot
color_palette <- c("#E69F00", "#56B4E9", "#009E73")
p_base <- ggplot(pred_dens) + 
#    geom_col(aes(x=inc_bin, fill=mdl)) + 
#    geom_bar(aes(x=inc_bin, fill=factor(mdl)), stat="identity", position = position_stack()) +
    scale_fill_manual(breaks = c("KCDE", "KDE", "SARIMA"), values = color_palette) +
    xlab("peak incidence value (binned wILI)") +
    coord_cartesian(xlim=c(0, 11), ylim=c(0, 0.5)) +
    theme_minimal() + 
    theme(legend.position = "none", panel.grid.minor=element_blank())

## left hand tri-part panel
p1 <- p_base + aes(y=probability) + theme(strip.text.y = element_blank())+
    geom_bar(aes(x=inc_bin, fill=factor(mdl)), stat="identity", position = position_stack()) +
    facet_grid(mdl~.) + ggtitle("A: Original predictions") +
    geom_text(data=weights, aes(x=7.4, y=y, label=mdl), hjust=0, size=5)

## center tri-part panel
p2 <- p_base + aes(y=probability * weight) + 
    geom_bar(aes(x=inc_bin, fill=factor(mdl)), stat="identity", position = position_stack()) +
    facet_grid(mdl~.) + ggtitle("B: Weighted predictions") +
    theme(strip.text.y = element_blank(), axis.title.y = element_blank()) +
    geom_text(data=weights, parse=TRUE,
        aes(x=x, y=y, label=paste(expression(pi[m]), "==", weight)))

## make complicated right hand panel

## top and bottom RHS
blankPlot <- ggplot() + geom_blank(aes(x=c(0,1),y=c(0,1))) +
    cowplot::theme_nothing()

title_plot <- blankPlot + 
    geom_text(aes(x=0, y=.1,label="C: Stacked prediction"), hjust=0, size=4.5)

axis_plot <- blankPlot + 
    geom_text(aes(x=.5, y=0.9,label="peak incidence value (binned wILI)"), size=4)

## middle left
p3 <- p_base + aes(y=probability * weight) + 
    geom_bar(aes(x=inc_bin, fill=factor(mdl, levels = rev(levels(mdl)))), stat="identity", position = position_stack()) +
    theme(axis.title.y = element_blank(), axis.title.x=element_blank(),
      plot.margin = unit(c(2, 6, 0, 6), "pt")) 

p4 <- grid.arrange(title_plot, p3, axis_plot)

grid.arrange(p1, p2, p4, ncol=3)

```


```{r log_scores_vs_analysis_time, echo=FALSE, cache=TRUE, fig.height=8, fig.cap="\\label{fig:ComponentModelLogScoresVsWeek}Mean, minimum, and maximum log scores achieved by each component model in each week of the season, summarizing across all seasons in both the training phase when all three component models produced predictions.", fig.show='hide'}
awes_path <- find.package("awes")
color_palette <- c("#E69F00", "#56B4E9", "#009E73")

log_scores <- bind_rows(
    assemble_predictions(
      preds_path = file.path(awes_path, "estimation/loso-predictions"),
      regions = c("National", paste0("Region", 1:10)),
      models = c("kde", "kcde", "sarima"),
      prediction_targets = c("onset", "peak_week", "peak_inc"),
      prediction_types = c("log_score")
    )
  ) %>%
  gather_("prediction_target", "log_score",
    paste0(c("onset", "peak_week", "peak_inc"), "_log_score")) %>%
  mutate(prediction_target = substr(prediction_target, 1, nchar(prediction_target) - 10))


summarized_log_scores <- log_scores %>%
  filter(analysis_time_season %in% paste0(1999:2015, "/", 2000:2016)) %>%
  group_by(model, region, prediction_target, analysis_time_season_week) %>%
  summarize(
    mean_log_score = mean(log_score),
    min_log_score = min(log_score),
    max_log_score = max(log_score)) %>%
  mutate(Model = toupper(model))
summarized_log_scores$prediction_target[summarized_log_scores$prediction_target == "onset"] <- "Onset Timing"
summarized_log_scores$prediction_target[summarized_log_scores$prediction_target == "peak_inc"] <- "Peak Incidence"
summarized_log_scores$prediction_target[summarized_log_scores$prediction_target == "peak_week"] <- "Peak Timing"
summarized_log_scores$prediction_target <- factor(summarized_log_scores$prediction_target,
  levels = c("Onset Timing", "Peak Timing", "Peak Incidence"))

regions_to_plot <- c("National", "Region1", "Region7")

ggplot() +
  geom_ribbon(
    aes(x = analysis_time_season_week,
      ymin = min_log_score,
      ymax = max_log_score,
      colour = Model,
      fill = Model,
      linetype = Model),
    alpha = 0.2,
    data = summarized_log_scores[summarized_log_scores$region %in% regions_to_plot, ]) +
  geom_line(
    aes(x = analysis_time_season_week,
      y = mean_log_score,
      colour = Model,
      linetype = Model),
    size = 1.5,
    data = summarized_log_scores[summarized_log_scores$region %in% regions_to_plot, ]) +
  scale_fill_manual(values = color_palette) +
  scale_colour_manual(values = color_palette) +
  facet_grid(region ~ prediction_target) +
  xlab("Week of Season at Analysis Time") +
  ylab("Log Score") +
  ggtitle("Log Scores vs. Week of Season at Analysis Time") +
  theme_bw()
```


```{r log_scores_and_weights_vs_analysis_time_setup, echo=FALSE, cache=TRUE}
get_legend_grob <- function(x) {
  data <- ggplot2:::ggplot_build(x)
  
  plot <- data$plot
  panel <- data$panel
  data <- data$data
  theme <- ggplot2:::plot_theme(plot)
  position <- theme$legend.position
  if (length(position) == 2) {
    position <- "manual"
  }
  
  legend_box <- if (position != "none") {
    ggplot2:::build_guides(plot$scales, plot$layers, plot$mapping, 
      position, theme, plot$guides, plot$labels)
  } else {
    ggplot2:::zeroGrob()
  }
  if (ggplot2:::is.zero(legend_box)) {
    position <- "none"
  }
  else {
    legend_width <- gtable:::gtable_width(legend_box) + theme$legend.margin
    legend_height <- gtable:::gtable_height(legend_box) + theme$legend.margin
    just <- valid.just(theme$legend.justification)
    xjust <- just[1]
    yjust <- just[2]
    if (position == "manual") {
      xpos <- theme$legend.position[1]
      ypos <- theme$legend.position[2]
      legend_box <- editGrob(legend_box, vp = viewport(x = xpos, 
        y = ypos, just = c(xjust, yjust), height = legend_height, 
        width = legend_width))
    }
    else {
      legend_box <- editGrob(legend_box, vp = viewport(x = xjust, 
        y = yjust, just = c(xjust, yjust)))
    }
  }
  return(legend_box)
}


awes_path <- find.package("awes")
color_palette <- c("#E69F00", "#56B4E9", "#009E73")

log_scores <- bind_rows(
    assemble_predictions(
      preds_path = file.path(awes_path, "estimation/loso-predictions"),
      regions = c("National", paste0("Region", 1:10)),
      models = c("kde", "kcde", "sarima"),
      prediction_targets = c("onset", "peak_week", "peak_inc"),
      prediction_types = c("log_score")
    )
  ) %>%
  gather_("prediction_target", "log_score",
    paste0(c("onset", "peak_week", "peak_inc"), "_log_score")) %>%
  mutate(prediction_target = substr(prediction_target, 1, nchar(prediction_target) - 10))


summarized_log_scores <- log_scores %>%
  filter(analysis_time_season %in% paste0(1999:2015, "/", 2000:2016) &
      prediction_target == "onset" &
      region == "National") %>%
  group_by(model, analysis_time_season_week) %>%
  summarize(
    mean_log_score = mean(log_score),
    min_log_score = min(log_score),
    max_log_score = max(log_score)) %>%
  mutate(Model = toupper(model),
    quantity = "Component Model Log Scores")

awes_path <- find.package("awes")

model_weights <- rbind.fill(
  readRDS(file.path(awes_path, "estimation/em-stacking/fits/em_weights.rds")) %>%
    filter(analysis_time_season_week == "all-combined" &
      region == "National" &
      prediction_target == "onset") %>%
    transmute(
      KDE = kde,
      KCDE = kcde,
      SARIMA = sarima,
      junk = TRUE
    ) %>%
    right_join(
      data.frame(
        junk = TRUE,
        ensemble_method = "CW",
        analysis_time_season_week = 10:40
      ),
      by = "junk"
    ) %>%
    gather_("model", "weight", c("KDE", "KCDE", "SARIMA")) %>%
    select_(.dots =
        c("ensemble_method", "analysis_time_season_week", "model", "weight")),
  readRDS(
    file = file.path(awes_path,
      "estimation/xgb-stacking/fits/model_weights_National_onset_analysis_time_season_week.rds")) %>%
    select_(.dots = c("analysis_time_season_week", paste0(c("kde", "kcde", "sarima"), "_log_score_params_combined"))) %>%
    `colnames<-`(c("analysis_time_season_week", "KDE", "KCDE", "SARIMA")) %>%
    gather_("model", "weight", c("KDE", "KCDE", "SARIMA")) %>%
    mutate(ensemble_method = "FW-reg-w")
) %>%
  mutate(quantity = "Component Model Weights")

p_onset_scores <- ggplot() +
  geom_ribbon(
    aes(x = analysis_time_season_week,
      ymin = min_log_score,
      ymax = max_log_score,
      colour = Model,
      fill = Model,
      linetype = Model),
    alpha = 0.2,
    data = summarized_log_scores[summarized_log_scores$analysis_time_season_week %in% 10:40, ]) +
  geom_line(
    aes(x = analysis_time_season_week,
      y = mean_log_score,
      colour = Model,
      linetype = Model),
    size = 1.5,
    data = summarized_log_scores[summarized_log_scores$analysis_time_season_week %in% 10:40, ]) +
#  facet_wrap( ~ quantity) +
  scale_fill_manual("Component\nModel", values = color_palette) +
  scale_colour_manual("Component\nModel", values = color_palette) +
  scale_linetype("Component\nModel") +
  ylim(c(-10.2,0)) +
#  xlab("Week of Season at Analysis Time") +
#  ylab("Log Score") +
#  ggtitle("A: Component Model Log Scores") +
  theme_bw(base_size = 11) +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    plot.margin = unit(c(6, 6, 0, 0), "pt"))

p_onset_weights <- ggplot() +
  geom_line(aes(x = analysis_time_season_week,
      y = weight,
      colour = model,
      linetype = model,
      size = ensemble_method
    ),
    data = model_weights[model_weights$analysis_time_season_week %in% 10:40, ]) +
#  facet_wrap( ~ quantity) +
  scale_linetype("Model") +
  scale_colour_manual("Model", values = color_palette) +
  scale_size_manual("Ensemble\nModel", breaks = c("CW", "FW-reg-w"), values = c(0.5, 1.5)) +
  ylim(c(0,1)) +
  xlab("Week of Season at Analysis Time") +
#  ylab("Model Weight") +
#  ggtitle("B: Component Model Weights") +
  theme_bw(base_size = 11) +
  theme(axis.title.y = element_blank(),
    legend.position = "none",
    plot.margin = unit(c(3, 6, 0, 5), "pt"))

component_legend <- get_legend_grob(p_onset_scores)
p_onset_scores <- p_onset_scores +
  theme(legend.position = "none")

ensemble_legend <- get_legend_grob(
  ggplot() +
  geom_line(aes(x = analysis_time_season_week,
      y = weight,
      size = ensemble_method
    ),
    data = model_weights) +
  scale_size_manual("Ensemble\nModel", breaks = c("CW", "FW-reg-w"), values = c(0.5, 1.5)) +
  theme_bw(base_size = 11)
)


summarized_log_scores <- log_scores %>%
  filter(analysis_time_season %in% paste0(1999:2015, "/", 2000:2016) &
      prediction_target == "peak_week" &
      region == "National") %>%
  group_by(model, analysis_time_season_week) %>%
  summarize(
    mean_log_score = mean(log_score),
    min_log_score = min(log_score),
    max_log_score = max(log_score)) %>%
  mutate(Model = toupper(model),
    quantity = "Component Model Log Scores")

model_weights <- rbind.fill(
  readRDS(file.path(awes_path, "estimation/em-stacking/fits/em_weights.rds")) %>%
    filter(analysis_time_season_week == "all-combined" &
      region == "National" &
      prediction_target == "peak_week") %>%
    transmute(
      KDE = kde,
      KCDE = kcde,
      SARIMA = sarima,
      junk = TRUE
    ) %>%
    right_join(
      data.frame(
        junk = TRUE,
        ensemble_method = "CW",
        analysis_time_season_week = 10:40
      ),
      by = "junk"
    ) %>%
    gather_("model", "weight", c("KDE", "KCDE", "SARIMA")) %>%
    select_(.dots =
        c("ensemble_method", "analysis_time_season_week", "model", "weight")),
  readRDS(
    file = file.path(awes_path,
      "estimation/xgb-stacking/fits/model_weights_National_peak_week_analysis_time_season_week.rds")) %>%
    select_(.dots = c("analysis_time_season_week", paste0(c("kde", "kcde", "sarima"), "_log_score_params_combined"))) %>%
    `colnames<-`(c("analysis_time_season_week", "KDE", "KCDE", "SARIMA")) %>%
    gather_("model", "weight", c("KDE", "KCDE", "SARIMA")) %>%
    mutate(ensemble_method = "FW-reg-w")
) %>%
  mutate(quantity = "Component Model Weights")

p_peak_week_scores <- ggplot() +
  geom_ribbon(
    aes(x = analysis_time_season_week,
      ymin = min_log_score,
      ymax = max_log_score,
      colour = Model,
      fill = Model,
      linetype = Model),
    alpha = 0.2,
    data = summarized_log_scores[summarized_log_scores$analysis_time_season_week %in% 10:40, ]) +
  geom_line(
    aes(x = analysis_time_season_week,
      y = mean_log_score,
      colour = Model,
      linetype = Model),
    size = 1.5,
    data = summarized_log_scores[summarized_log_scores$analysis_time_season_week %in% 10:40, ]) +
#  facet_wrap( ~ quantity) +
  scale_fill_manual("Component\nModel", values = color_palette) +
  scale_colour_manual("Component\nModel", values = color_palette) +
  scale_linetype("Component\nModel") +
  ylim(c(-10.2,0)) +
#  xlab("Week of Season at Analysis Time") +
#  ylab("Log Score") +
#  ggtitle("A: Component Model Log Scores") +
  theme_bw(base_size = 11) +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "none",
    plot.margin = unit(c(6, 6, 0, 0), "pt"))

p_peak_week_weights <- ggplot() +
  geom_line(aes(x = analysis_time_season_week,
      y = weight,
      colour = model,
      linetype = model,
      size = ensemble_method
    ),
    data = model_weights[model_weights$analysis_time_season_week %in% 10:40, ]) +
#  facet_wrap( ~ quantity) +
  scale_linetype("Model") +
  scale_colour_manual("Model", values = color_palette) +
  scale_size_manual("Ensemble\nModel", breaks = c("CW", "FW-reg-w"), values = c(0.5, 1.5)) +
  ylim(c(0,1)) +
  xlab("Week of Season at Analysis Time") +
#  ylab("Model Weight") +
#  ggtitle("B: Component Model Weights") +
  theme_bw(base_size = 11) +
  theme(axis.title.y = element_blank(),
    legend.position = "none",
    plot.margin = unit(c(3, 6, 0, 5), "pt"))




summarized_log_scores <- log_scores %>%
  filter(analysis_time_season %in% paste0(1999:2015, "/", 2000:2016) &
      prediction_target == "peak_inc" &
      region == "National") %>%
  group_by(model, analysis_time_season_week) %>%
  summarize(
    mean_log_score = mean(log_score),
    min_log_score = min(log_score),
    max_log_score = max(log_score)) %>%
  mutate(Model = toupper(model),
    quantity = "Component Model Log Scores")

model_weights <- rbind.fill(
  readRDS(file.path(awes_path, "estimation/em-stacking/fits/em_weights.rds")) %>%
    filter(analysis_time_season_week == "all-combined" &
      region == "National" &
      prediction_target == "peak_inc") %>%
    transmute(
      KDE = kde,
      KCDE = kcde,
      SARIMA = sarima,
      junk = TRUE
    ) %>%
    right_join(
      data.frame(
        junk = TRUE,
        ensemble_method = "CW",
        analysis_time_season_week = 10:40
      ),
      by = "junk"
    ) %>%
    gather_("model", "weight", c("KDE", "KCDE", "SARIMA")) %>%
    select_(.dots =
        c("ensemble_method", "analysis_time_season_week", "model", "weight")),
  readRDS(
    file = file.path(awes_path,
      "estimation/xgb-stacking/fits/model_weights_National_peak_inc_analysis_time_season_week.rds")) %>%
    select_(.dots = c("analysis_time_season_week", paste0(c("kde", "kcde", "sarima"), "_log_score_params_combined"))) %>%
    `colnames<-`(c("analysis_time_season_week", "KDE", "KCDE", "SARIMA")) %>%
    gather_("model", "weight", c("KDE", "KCDE", "SARIMA")) %>%
    mutate(ensemble_method = "FW-reg-w")
) %>%
  mutate(quantity = "Component Model Weights")

p_peak_inc_scores <- ggplot() +
  geom_ribbon(
    aes(x = analysis_time_season_week,
      ymin = min_log_score,
      ymax = max_log_score,
      colour = Model,
      fill = Model,
      linetype = Model),
    alpha = 0.2,
    data = summarized_log_scores[summarized_log_scores$analysis_time_season_week %in% 10:40, ]) +
  geom_line(
    aes(x = analysis_time_season_week,
      y = mean_log_score,
      colour = Model,
      linetype = Model),
    size = 1.5,
    data = summarized_log_scores[summarized_log_scores$analysis_time_season_week %in% 10:40, ]) +
#  facet_wrap( ~ quantity) +
  scale_fill_manual("Component\nModel", values = color_palette) +
  scale_colour_manual("Component\nModel", values = color_palette) +
  scale_linetype("Component\nModel") +
  ylim(c(-10.2,0)) +
#  xlab("Week of Season at Analysis Time") +
#  ylab("Log Score") +
#  ggtitle("A: Component Model Log Scores") +
  theme_bw(base_size = 11) +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "none",
    plot.margin = unit(c(6, 6, 0, 0), "pt"))

p_peak_inc_weights <- ggplot() +
  geom_line(aes(x = analysis_time_season_week,
      y = weight,
      colour = model,
      linetype = model,
      size = ensemble_method
    ),
    data = model_weights[model_weights$analysis_time_season_week %in% 10:40, ]) +
#  facet_wrap( ~ quantity) +
  scale_linetype("Model") +
  scale_colour_manual("Model", values = color_palette) +
  scale_size_manual("Ensemble\nModel", breaks = c("CW", "FW-reg-w"), values = c(0.5, 1.5)) +
  ylim(c(0,1)) +
  xlab("Week of Season at Analysis Time") +
#  ylab("Model Weight") +
#  ggtitle("B: Component Model Weights") +
  theme_bw(base_size = 11) +
  theme(axis.title.y = element_blank(),
    legend.position = "none",
    plot.margin = unit(c(3, 6, 0, 5), "pt"))
```

```{r log_scores_and_weights_vs_analysis_time, echo=FALSE, cache=TRUE, fig.height=8, fig.cap="\\label{fig:example-weights}Example of component model weights from the \\textbf{CW} and \\textbf{FW-reg-w} models for National predictions.  The upper plot within each panel shows mean, minimum, and maximum log scores achieved by each component model for predictions of the given prediction target at the national level in each week of the season, summarizing across all seasons in the training phase when all three component models produced predictions.  The lower plot within each panel shows model weights from the \\textbf{CW} and \\textbf{FW-reg-w} ensemble methods at each week in the season."}
grid.newpage()
blank_height <- 0
rel_height_lower <- 1.35
pushViewport(viewport(layout =
    grid.layout(nrow = 11, ncol = 3,
      heights = unit(
        c(1, 1, rel_height_lower, blank_height, 1, 1, rel_height_lower, blank_height, 1, 1, rel_height_lower),
        rep(c("lines", "lines", "null", "null"), 3)[2:12]),
      widths = unit(c(1, 4, 1), c("lines", "null", "null")))))
grid.text("A: Onset Timing",
  just = "left",
  gp = gpar(fontsize = 12),
  vp = viewport(layout.pos.row = 1, layout.pos.col = 1))
grid.text("B: Peak Timing",
  just = "left",
  gp = gpar(fontsize = 12),
  vp = viewport(layout.pos.row = 5, layout.pos.col = 1))
grid.text("C: Peak Incidence",
  just = "left",
  gp = gpar(fontsize = 12),
  vp = viewport(layout.pos.row = 9, layout.pos.col = 1))

ls_str <- "Log Score   "
mw_str <- "       Model Weight"
grid.text(ls_str,
  rot = 90,
  gp = gpar(fontsize = 10),
  vp = viewport(layout.pos.row = 2, layout.pos.col = 1))
grid.text(mw_str,
  rot = 90,
  gp = gpar(fontsize = 10),
  vp = viewport(layout.pos.row = 3, layout.pos.col = 1))
grid.text(ls_str,
  rot = 90,
  gp = gpar(fontsize = 10),
  vp = viewport(layout.pos.row = 6, layout.pos.col = 1))
grid.text(mw_str,
  rot = 90,
  gp = gpar(fontsize = 10),
  vp = viewport(layout.pos.row = 7, layout.pos.col = 1))
grid.text(ls_str,
  rot = 90,
  gp = gpar(fontsize = 10),
  vp = viewport(layout.pos.row = 10, layout.pos.col = 1))
grid.text(mw_str,
  rot = 90,
  gp = gpar(fontsize = 10),
  vp = viewport(layout.pos.row = 11, layout.pos.col = 1))

print(p_onset_scores, vp = viewport(layout.pos.row = 2, layout.pos.col = 2))
print(p_onset_weights, vp = viewport(layout.pos.row = 3, layout.pos.col = 2))
print(p_peak_week_scores, vp = viewport(layout.pos.row = 6, layout.pos.col = 2))
print(p_peak_week_weights, vp = viewport(layout.pos.row = 7, layout.pos.col = 2))
print(p_peak_inc_scores, vp = viewport(layout.pos.row = 10, layout.pos.col = 2))
print(p_peak_inc_weights, vp = viewport(layout.pos.row = 11, layout.pos.col = 2))

pushViewport(viewport(layout.pos.row = 6, layout.pos.col = 3))
grid.draw(component_legend)
upViewport()
pushViewport(viewport(layout.pos.row = 7, layout.pos.col = 3))
grid.draw(ensemble_legend)
upViewport()
```

```{r fw_reg_wu_model_weights, echo=FALSE, cache=TRUE, fig.height=8, fig.cap="\\label{fig:FWregwuModelWeights}Weights assigned to each component model by the FW-reg-wu model for the prediction of season peak incidence at the national level. There are three weighting functions (one for each component model) represented in each row of the figure. The value of the weight is depicted by the color. Each function depends on three features: the week of the season at the time when the predictions are made, KCDE model uncertainty, and SARIMA model uncertainty. Model uncertainty represents the minimum number of predictive distribution bins required to cover 90% probability of the predictive distribution, so the higher this number is the more uncertain the model is."}
get_legend_grob <- function(x) {
  data <- ggplot2:::ggplot_build(x)
  
  plot <- data$plot
  panel <- data$panel
  data <- data$data
  theme <- ggplot2:::plot_theme(plot)
  position <- theme$legend.position
  if (length(position) == 2) {
    position <- "manual"
  }
  
  legend_box <- if (position != "none") {
    ggplot2:::build_guides(plot$scales, plot$layers, plot$mapping, 
      position, theme, plot$guides, plot$labels)
  } else {
    ggplot2:::zeroGrob()
  }
  if (ggplot2:::is.zero(legend_box)) {
    position <- "none"
  }
  else {
    legend_width <- gtable:::gtable_width(legend_box) + theme$legend.margin
    legend_height <- gtable:::gtable_height(legend_box) + theme$legend.margin
    just <- valid.just(theme$legend.justification)
    xjust <- just[1]
    yjust <- just[2]
    if (position == "manual") {
      xpos <- theme$legend.position[1]
      ypos <- theme$legend.position[2]
      legend_box <- editGrob(legend_box, vp = viewport(x = xpos, 
        y = ypos, just = c(xjust, yjust), height = legend_height, 
        width = legend_width))
    }
    else {
      legend_box <- editGrob(legend_box, vp = viewport(x = xjust, 
        y = yjust, just = c(xjust, yjust)))
    }
  }
  return(legend_box)
}

awes_path <- find.package("awes")
loso_preds_path <- file.path(awes_path, "estimation/loso-predictions")
stacking_model_fits_path <- file.path(awes_path, "estimation/xgb-stacking/fits")

component_model_names <- c("kde", "kcde", "sarima")
region <- "National"
prediction_target <- "peak_inc"
explanatory_variables <- "analysis_time_season_week-kcde_model_confidence-sarima_model_confidence"
explanatory_variables_split <- strsplit(explanatory_variables, "-")[[1]]
ensemble_model_name <- "xgb_stacking_reg_wu"

weights <- readRDS(
  file = file.path(stacking_model_fits_path,
    paste0("model_weights_", region, "_", prediction_target, "_", explanatory_variables, ".rds"))) %>%
  select_(.dots = c(explanatory_variables_split, paste0(component_model_names, "_log_score_params_combined"))) %>%
  `colnames<-`(c(explanatory_variables_split, component_model_names)) %>%
  mutate(region = region,
    prediction_target = prediction_target)

weights <- weights %>%
  gather_("model", "weight", c("kde", "kcde", "sarima"))

typical_season_week <- 17L
if(prediction_target %in% c("onset", "peak_week")) {
  typical_confidence <- 5L
} else {
  typical_confidence <- 20L
}

p1 <- ggplot(
  weights %>%
    filter(sarima_model_confidence == typical_confidence &
        kcde_model_confidence %% 2 == 1) %>%
    mutate(model = toupper(model))) +
  geom_raster(aes(x = analysis_time_season_week, y = kcde_model_confidence, fill = weight)) +
  scale_fill_gradient2("Model\nWeight",
    breaks = c(0, 0.25, 0.5, 0.75, 1),
    labels = as.character(c(0, 0.25, 0.5, 0.75, 1)),
    low = "#b2182b",
    mid = "#f7f7f7",
    high = "#2166ac",
    midpoint = 0.5) +
  facet_wrap(~ model, nrow = 1L) +
  xlab("Season Week at Analysis Time") +
  ylab("KCDE Model Uncertainty") +
  theme_bw()
  
plot_legend <- get_legend_grob(p1)

p1 <- p1 + theme(legend.position = "none")

p2 <- ggplot(
  weights %>%
    filter(kcde_model_confidence == typical_confidence &
        sarima_model_confidence %% 2 == 1) %>%
    mutate(model = toupper(model))) +
  geom_raster(aes(x = analysis_time_season_week, y = sarima_model_confidence, fill = weight)) +
  scale_fill_gradient2("Model\nWeight",
    breaks = c(0, 0.25, 0.5, 0.75, 1),
    labels = as.character(c(0, 0.25, 0.5, 0.75, 1)),
    low = "#b2182b",
    mid = "#f7f7f7",
    high = "#2166ac",
    midpoint = 0.5) +
  facet_wrap(~ model, nrow = 1L) +
  xlab("Season Week at Analysis Time") +
  ylab("SARIMA Model Uncertainty") +
  theme_bw() +
  theme(legend.position = "none")

p3 <- ggplot(
  weights %>%
    filter(
      analysis_time_season_week == typical_season_week &
      kcde_model_confidence %%2 == 1 &
      sarima_model_confidence %% 2 == 1) %>%
    mutate(model = toupper(model))) +
  geom_raster(aes(x = kcde_model_confidence, y = sarima_model_confidence, fill = weight)) +
  scale_fill_gradient2("Model\nWeight",
    breaks = c(0, 0.25, 0.5, 0.75, 1),
    labels = as.character(c(0, 0.25, 0.5, 0.75, 1)),
    low = "#b2182b",
    mid = "#f7f7f7",
    high = "#2166ac",
    midpoint = 0.5) +
  facet_wrap(~ model, nrow = 1L) +
  xlab("KCDE Model Uncertainty") +
  ylab("SARIMA Model Uncertainty") +
  theme_bw() +
  theme(legend.position = "none")
  

grid.newpage()
num_lines_text <- 1
pushViewport(viewport(layout =
    grid.layout(nrow = 6, ncol = 2,
      heights = unit(
        c(num_lines_text, 1, num_lines_text, 1, num_lines_text, 1),
        rep(c("lines", "null"), 3)),
      widths = unit(c(4, 1), c("null", "null")))))
grid.text("A: SARIMA Model Uncertainty Fixed at 20",
  x = unit(0, "npc"),
  just = "left",
  gp = gpar(fontsize = 12),
  vp = viewport(layout.pos.row = 1, layout.pos.col = 1:2))
grid.text("B: KCDE Model Uncertainty Fixed at 20",
  x = unit(0, "npc"),
  just = "left",
  gp = gpar(fontsize = 12),
  vp = viewport(layout.pos.row = 3, layout.pos.col = 1:2))
grid.text("C: Season Week Fixed at 17",
  x = unit(0, "npc"),
  just = "left",
  gp = gpar(fontsize = 12),
  vp = viewport(layout.pos.row = 5, layout.pos.col = 1:2))

print(p1, vp = viewport(layout.pos.row = 2, layout.pos.col = 1))
print(p2, vp = viewport(layout.pos.row = 4, layout.pos.col = 1))
print(p3, vp = viewport(layout.pos.row = 6, layout.pos.col = 1))

pushViewport(viewport(layout.pos.row = 3:4, layout.pos.col = 2))
grid.draw(plot_legend)
upViewport()
```

\begin{table}[!ht]
\centering
\caption{\label{tbl:ModelPerformanceSummaryTable}Summary of average log scores and variance of log scores across all spatial units and test phase seasons for each method.}
\begin{tabular}{r c c m{0.05cm} c c m{0.05cm} c c}
\toprule
& \multicolumn{2}{c}{Onset Timing} & & \multicolumn{2}{c}{Peak Timing} & & \multicolumn{2}{c}{Peak Incidence} \\
\cline{2-3} \cline{5-6} \cline{8-9}
 Model & Mean & Variance & & Mean & Variance & & Mean & Variance \\ 
\hline
```{r summarized_results_table, echo = FALSE, results = "asis"}
awes_path <- find.package("awes")

region_season_obs_quantities <- flu_data %>%
  select_(.dots = c("region", "season")) %>%
  distinct() %>%
  filter(season %in% paste0(2011:2015, "/", 2012:2016)) %>%
  mutate(
    observed_onset_week = NA,
    observed_peak_week = NA
  )

for(rs_row in seq_len(nrow(region_season_obs_quantities))) {
  temp <- get_observed_seasonal_quantities(
    data = flu_data[flu_data$region == region_season_obs_quantities$region[rs_row], , drop = FALSE],
    season = region_season_obs_quantities$season[rs_row],
    first_CDC_season_week = 10,
    last_CDC_season_week = 42,
    onset_baseline =
      get_onset_baseline(region = region_season_obs_quantities$region[rs_row],
        season = region_season_obs_quantities$season[rs_row]),
    incidence_var = "weighted_ili",
    incidence_bins = data.frame(
      lower = c(0, seq(from = 0.05, to = 12.95, by = 0.1)),
      upper = c(seq(from = 0.05, to = 12.95, by = 0.1), Inf)),
    incidence_bin_names = as.character(seq(from = 0, to = 13, by = 0.1))
  )

  region_season_obs_quantities$observed_onset_week[rs_row] <-
    temp$observed_onset_week
  region_season_obs_quantities$observed_peak_week[rs_row] <-
    temp$observed_peak_week[1]
}

region_season_obs_quantities$observed_onset_week[
  region_season_obs_quantities$observed_onset_week == "none"] <- 42
region_season_obs_quantities <- region_season_obs_quantities %>%
  transmute(
    region = ifelse(region == "X", "National", gsub(" ", "", region)),
    analysis_time_season = season,
    observed_onset_week = as.numeric(observed_onset_week),
    observed_peak_week = observed_peak_week
  )

all_models <- c("kde", "kcde", "sarima", "equal_weights", "em_stacking", "xgb_stacking_unregularized", "xgb_stacking_reg_w", "xgb_stacking_reg_wu", "xgb_stacking_reg_wui")
all_targets <- c("onset", "peak_week", "peak_inc")
preds <- assemble_predictions(
  preds_path = file.path(awes_path, "evaluation/test-predictions"),
  models = all_models,
  prediction_targets = all_targets,
  prediction_types = "log_score"
) %>%
  filter(analysis_time_season_week %in% 10:40) %>%
  gather_("prediction_target", "log_score",
    c("onset_log_score", "peak_week_log_score", "peak_inc_log_score")) %>%
  mutate(
    prediction_target = substr(prediction_target, 1, nchar(prediction_target) - 10),
    score = exp(log_score)
  )

preds$log_score[is.infinite(preds$log_score)] <- -10
preds <- preds %>%
  left_join(region_season_obs_quantities, by = c("region", "analysis_time_season")) %>%
  mutate(
    before_onset = (analysis_time_season_week < observed_onset_week),
    before_peak = (analysis_time_season_week < observed_peak_week))

preds$before_target_date <- ifelse(
  preds$prediction_target == "onset",
  c("on or after\ntarget date", "before\ntarget date")[preds$before_onset + 1],
  c("on or after\ntarget date", "before\ntarget date")[preds$before_peak + 1]
)

preds$model[preds$model == "kde"] <- "KDE"
preds$model[preds$model == "kcde"] <- "KCDE"
preds$model[preds$model == "sarima"] <- "SARIMA"
preds$model[preds$model == "equal_weights"] <- "EW"
preds$model[preds$model == "em_stacking"] <- "CW"
preds$model[preds$model == "xgb_stacking_unregularized"] <- "FW-wu"
preds$model[preds$model == "xgb_stacking_reg_w"] <- "FW-reg-w"
preds$model[preds$model == "xgb_stacking_reg_wu"] <- "FW-reg-wu"
preds$model[preds$model == "xgb_stacking_reg_wui"] <- "FW-reg-wui"
preds$model <- factor(preds$model,
  levels = c("KDE", "KCDE", "SARIMA",
    "EW", "CW", "FW-wu",
    "FW-reg-w", "FW-reg-wu", "FW-reg-wui"))

preds$prediction_target[preds$prediction_target == "onset"] <- "Onset Timing"
preds$prediction_target[preds$prediction_target == "peak_inc"] <- "Peak Incidence"
preds$prediction_target[preds$prediction_target == "peak_week"] <- "Peak Timing"
preds$prediction_target <- factor(preds$prediction_target,
  levels = c("Onset Timing", "Peak Timing", "Peak Incidence"))

preds <- preds %>%
  mutate(
    region = factor(region),
    analysis_time_season = factor(analysis_time_season)
  )

preds_wide <- preds %>%
  dplyr::filter(before_target_date == "before\ntarget date") %>%
  dplyr::select(-score) %>%
  tidyr::spread(model, log_score)


summarized_res <-
  preds_wide[, c("KDE", "KCDE", "SARIMA", "EW", "CW", "FW-wu", "FW-reg-w", "FW-reg-wu", "FW-reg-wui", "prediction_target")] %>%
#  select_(.dots = c("KDE", "KCDE", "SARIMA", "EW", "CW", `FW-wu`, `FW-reg-w`, `FW-reg-wu`, `FW-reg-wui`, "prediction_target")) %>%
#  select_(.dots = c("KDE", "KCDE", "SARIMA", "EW", "CW", "FW-wu", "FW-reg-w", "FW-reg-wu", "FW-reg-wui", "prediction_target")) %>%
  group_by(prediction_target) %>%
  summarize_each(funs(mean, var)) %>%
  t() %>%
  `colnames<-`(.[1, ])
for(model_val in c("KDE", "KCDE", "SARIMA", "EW", "CW", "FW-wu", "FW-reg-w", "FW-reg-wu", "FW-reg-wui")) {
  cat(model_val)
  for(target_val in colnames(summarized_res)) {
    cat(" & ")
    cat(format(round(as.numeric(summarized_res[paste0(model_val, "_mean"), target_val]), 2), nsmall = 2))
    cat(" & ")
    cat(format(round(as.numeric(summarized_res[paste0(model_val, "_var"), target_val]), 2), nsmall = 2))
    if(target_val %in% colnames(summarized_res)[1:2]) {
      cat(" & ")
    }
  }
  cat(" \\\\\n")
}
```
\bottomrule
\end{tabular}
\end{table}

\begin{table}[!ht]
\centering
\caption{\label{tbl:ModelPerformanceSummaryTableCombined}Summary of average log scores and variance of log scores across all spatial units, test phase seasons, and prediction targets for each method.}
\begin{tabular}{r c c}
\toprule
 Model & Mean & Variance \\ 
\hline
```{r summarized_results_table_across_target, echo = FALSE, results = "asis"}
awes_path <- find.package("awes")

region_season_obs_quantities <- flu_data %>%
  select_(.dots = c("region", "season")) %>%
  distinct() %>%
  filter(season %in% paste0(2011:2015, "/", 2012:2016)) %>%
  mutate(
    observed_onset_week = NA,
    observed_peak_week = NA
  )

for(rs_row in seq_len(nrow(region_season_obs_quantities))) {
  temp <- get_observed_seasonal_quantities(
    data = flu_data[flu_data$region == region_season_obs_quantities$region[rs_row], , drop = FALSE],
    season = region_season_obs_quantities$season[rs_row],
    first_CDC_season_week = 10,
    last_CDC_season_week = 42,
    onset_baseline =
      get_onset_baseline(region = region_season_obs_quantities$region[rs_row],
        season = region_season_obs_quantities$season[rs_row]),
    incidence_var = "weighted_ili",
    incidence_bins = data.frame(
      lower = c(0, seq(from = 0.05, to = 12.95, by = 0.1)),
      upper = c(seq(from = 0.05, to = 12.95, by = 0.1), Inf)),
    incidence_bin_names = as.character(seq(from = 0, to = 13, by = 0.1))
  )

  region_season_obs_quantities$observed_onset_week[rs_row] <-
    temp$observed_onset_week
  region_season_obs_quantities$observed_peak_week[rs_row] <-
    temp$observed_peak_week[1]
}

region_season_obs_quantities$observed_onset_week[
  region_season_obs_quantities$observed_onset_week == "none"] <- 42
region_season_obs_quantities <- region_season_obs_quantities %>%
  transmute(
    region = ifelse(region == "X", "National", gsub(" ", "", region)),
    analysis_time_season = season,
    observed_onset_week = as.numeric(observed_onset_week),
    observed_peak_week = observed_peak_week
  )

all_models <- c("kde", "kcde", "sarima", "equal_weights", "em_stacking", "xgb_stacking_unregularized", "xgb_stacking_reg_w", "xgb_stacking_reg_wu", "xgb_stacking_reg_wui")
all_targets <- c("onset", "peak_week", "peak_inc")
preds <- assemble_predictions(
  preds_path = file.path(awes_path, "evaluation/test-predictions"),
  models = all_models,
  prediction_targets = all_targets,
  prediction_types = "log_score"
) %>%
  filter(analysis_time_season_week %in% 10:40) %>%
  gather_("prediction_target", "log_score",
    c("onset_log_score", "peak_week_log_score", "peak_inc_log_score")) %>%
  mutate(
    prediction_target = substr(prediction_target, 1, nchar(prediction_target) - 10),
    score = exp(log_score)
  )

preds$log_score[is.infinite(preds$log_score)] <- -10
preds <- preds %>%
  left_join(region_season_obs_quantities, by = c("region", "analysis_time_season")) %>%
  mutate(
    before_onset = (analysis_time_season_week < observed_onset_week),
    before_peak = (analysis_time_season_week < observed_peak_week))

preds$before_target_date <- ifelse(
  preds$prediction_target == "onset",
  c("on or after\ntarget date", "before\ntarget date")[preds$before_onset + 1],
  c("on or after\ntarget date", "before\ntarget date")[preds$before_peak + 1]
)

preds$model[preds$model == "kde"] <- "KDE"
preds$model[preds$model == "kcde"] <- "KCDE"
preds$model[preds$model == "sarima"] <- "SARIMA"
preds$model[preds$model == "equal_weights"] <- "EW"
preds$model[preds$model == "em_stacking"] <- "CW"
preds$model[preds$model == "xgb_stacking_unregularized"] <- "FW-wu"
preds$model[preds$model == "xgb_stacking_reg_w"] <- "FW-reg-w"
preds$model[preds$model == "xgb_stacking_reg_wu"] <- "FW-reg-wu"
preds$model[preds$model == "xgb_stacking_reg_wui"] <- "FW-reg-wui"
preds$model <- factor(preds$model,
  levels = c("KDE", "KCDE", "SARIMA",
    "EW", "CW", "FW-wu",
    "FW-reg-w", "FW-reg-wu", "FW-reg-wui"))

preds$prediction_target[preds$prediction_target == "onset"] <- "Onset Timing"
preds$prediction_target[preds$prediction_target == "peak_inc"] <- "Peak Incidence"
preds$prediction_target[preds$prediction_target == "peak_week"] <- "Peak Timing"
preds$prediction_target <- factor(preds$prediction_target,
  levels = c("Onset Timing", "Peak Timing", "Peak Incidence"))

preds <- preds %>%
  mutate(
    region = factor(region),
    analysis_time_season = factor(analysis_time_season)
  )

preds_wide <- preds %>%
  dplyr::filter(before_target_date == "before\ntarget date") %>%
  dplyr::select(-score) %>%
  tidyr::spread(model, log_score)


summarized_res <-
  preds_wide[, c("KDE", "KCDE", "SARIMA", "EW", "CW", "FW-wu", "FW-reg-w", "FW-reg-wu", "FW-reg-wui")] %>%
#  select_(.dots = c("KDE", "KCDE", "SARIMA", "EW", "CW", `FW-wu`, `FW-reg-w`, `FW-reg-wu`, `FW-reg-wui`, "prediction_target")) %>%
#  select_(.dots = c("KDE", "KCDE", "SARIMA", "EW", "CW", "FW-wu", "FW-reg-w", "FW-reg-wu", "FW-reg-wui", "prediction_target")) %>%
  summarize_each(funs(mean, var)) %>%
  t()

for(model_val in c("KDE", "KCDE", "SARIMA", "EW", "CW", "FW-wu", "FW-reg-w", "FW-reg-wu", "FW-reg-wui")) {
  cat(model_val)
  cat(" & ")
  cat(format(round(as.numeric(summarized_res[paste0(model_val, "_mean"), 1]), 2), nsmall = 2))
  cat(" & ")
  cat(format(round(as.numeric(summarized_res[paste0(model_val, "_var"), 1]), 2), nsmall = 2))
  cat(" \\\\\n")
}
```
\bottomrule
\end{tabular}
\end{table}






```{r test_phase_log_scores_summary_v1a, echo=FALSE, cache=TRUE, fig.height=8, fig.cap="\\label{fig:test_phase_log_score_boxplot}Log scores across all regions, seasons, and season weeks represented in box plots.  Log scores of negative infinity are represented with a cross at -15."}
awes_path <- find.package("awes")

region_season_obs_quantities <- flu_data %>%
  select_(.dots = c("region", "season")) %>%
  distinct() %>%
  filter(season %in% paste0(2011:2015, "/", 2012:2016)) %>%
  mutate(
    observed_onset_week = NA,
    observed_peak_week = NA
  )

for(rs_row in seq_len(nrow(region_season_obs_quantities))) {
  temp <- get_observed_seasonal_quantities(
    data = flu_data[flu_data$region == region_season_obs_quantities$region[rs_row], , drop = FALSE],
    season = region_season_obs_quantities$season[rs_row],
    first_CDC_season_week = 10,
    last_CDC_season_week = 42,
    onset_baseline =
      get_onset_baseline(region = region_season_obs_quantities$region[rs_row],
        season = region_season_obs_quantities$season[rs_row]),
    incidence_var = "weighted_ili",
    incidence_bins = data.frame(
      lower = c(0, seq(from = 0.05, to = 12.95, by = 0.1)),
      upper = c(seq(from = 0.05, to = 12.95, by = 0.1), Inf)),
    incidence_bin_names = as.character(seq(from = 0, to = 13, by = 0.1))
  )
  
  region_season_obs_quantities$observed_onset_week[rs_row] <-
    temp$observed_onset_week
  region_season_obs_quantities$observed_peak_week[rs_row] <-
    temp$observed_peak_week[1]
}

region_season_obs_quantities$observed_onset_week[
  region_season_obs_quantities$observed_onset_week == "none"] <- 42
region_season_obs_quantities <- region_season_obs_quantities %>%
  transmute(
    region = gsub(" ", "", region),
    analysis_time_season = season,
    observed_onset_week = as.numeric(observed_onset_week),
    observed_peak_week = observed_peak_week
  )
region_season_obs_quantities$region[region_season_obs_quantities$region == "X"] <- "National"

all_models <- c("kde", "kcde", "sarima", "equal_weights", "em_stacking", "xgb_stacking_unregularized", "xgb_stacking_reg_w", "xgb_stacking_reg_wu", "xgb_stacking_reg_wui")
all_targets <- c("onset", "peak_week", "peak_inc")
preds <- assemble_predictions(
  preds_path = file.path(awes_path, "evaluation/test-predictions"),
  models = all_models,
  prediction_targets = all_targets,
  prediction_types = "log_score"
) %>%
  filter(analysis_time_season_week %in% 10:40) %>%
  gather_("prediction_target", "log_score",
    c("onset_log_score", "peak_week_log_score", "peak_inc_log_score")) %>%
  mutate(
    prediction_target = substr(prediction_target, 1, nchar(prediction_target) - 10),
    model = factor(model, levels = all_models),
    score = exp(log_score)
  )
preds$log_score[is.infinite(preds$log_score)] <- -10
preds <- preds %>%
  left_join(region_season_obs_quantities, by = c("region", "analysis_time_season")) %>%
  mutate(
    before_onset = (analysis_time_season_week < observed_onset_week),
    before_peak = (analysis_time_season_week < observed_peak_week))
preds$before_target_date <- ifelse(
  preds$prediction_target == "onset",
  c("on or after\ntarget date", "before\ntarget date")[preds$before_onset + 1],
  c("on or after\ntarget date", "before\ntarget date")[preds$before_peak + 1]
)

unique_region_season_model_autocor <- preds %>%
  filter(before_target_date == "before\ntarget date") %>%
  select_("region", "analysis_time_season", "model", "prediction_target", "log_score") %>%
  group_by_("region", "analysis_time_season", "model", "prediction_target") %>%
  summarize(
    log_score_autocor = acf(log_score, plot = FALSE)[["acf"]][2, 1, 1]
  )
## set to 1 for kde
unique_region_season_model_autocor$log_score_autocor[
  is.na(unique_region_season_model_autocor$log_score_autocor)] <- 1

preds <- preds %>%
  mutate(
    region = factor(region),
    analysis_time_season = factor(analysis_time_season),
    model = factor(model),
    prediction_target = factor(prediction_target),
    unique_region_season_model_target = factor(
      paste(region, analysis_time_season, model, prediction_target, sep = "_")
    )
  )
results_fit_before_target <- lme(log_score ~ model * prediction_target,
  random = ~ 1 | unique_region_season_model_target,
  correlation = corAR1(
    value = mean(unique_region_season_model_autocor$log_score_autocor),
    form = ~ analysis_time_season_week | unique_region_season_model_target),
  method = "REML",
  data = preds[preds$before_target_date == "before\ntarget date", ])

num_models <- length(all_models)
num_targets <- length(all_targets)

unique_model_descriptors <- paste0("model", all_models)
unique_target_descriptors <- paste0("prediction_target", all_targets)

lc_df <- expand.grid(
  model = all_models,
  target = all_targets,
  stringsAsFactors = FALSE)

lc_df$model_descriptor <- paste0("model", lc_df$model)
lc_df$target_descriptor <- paste0("prediction_target", lc_df$target)
lc_df$name <- apply(as.matrix(lc_df[, 1:2]), 1, paste, collapse = "-")

num_leading_cols <- ncol(lc_df)
coef_cols <- seq(
  from = num_leading_cols + 1,
  length = num_models * num_targets
)

# corresponding indicator vector for each coefficient
coef_names <- names(fixef(results_fit_before_target))
unique_coef_name_component_descriptors <- unique(unlist(strsplit(coef_names, ":")))
intercept_model <- unique_model_descriptors[
  !(unique_model_descriptors %in% unique_coef_name_component_descriptors)]
intercept_target <- unique_target_descriptors[
  !(unique_target_descriptors %in% unique_coef_name_component_descriptors)]
for(coef_ind in seq(from = 1, to = length(coef_names))) {
	split_name <- unlist(strsplit(coef_names[[coef_ind]], ":"))
	if(!any(split_name %in% unique_model_descriptors[unique_model_descriptors != intercept_model])) {
		split_name <- c(split_name, unique_model_descriptors)
	}
	if(!any(split_name %in% unique_target_descriptors[unique_target_descriptors != intercept_target])) {
		split_name <- c(split_name, unique_target_descriptors)
	}

	lc_df[[paste0("coef", coef_ind)]] <- 0
	lc_df[[paste0("coef", coef_ind)]][
	  lc_df$model_descriptor %in% split_name &
		lc_df$target_descriptor %in% split_name] <- 1
}

model_row_inds <- seq_len(nrow(lc_df))

# ## contrasts of (mean performance model 1) - (mean performance model 2) for all model pairs
rowind <- nrow(lc_df)
for(prediction_target in all_targets) {
  for(fit_method1_ind in seq_len(length(all_models) - 1)) {
    for(fit_method2_ind in seq(from = fit_method1_ind + 1, to = length(all_models))) {
      rowind <- rowind + 1
   	  
      m1_name <- all_models[fit_method1_ind]
      m2_name <- all_models[fit_method2_ind]
      
      m1_rowind <- which(lc_df$name == paste(m1_name, prediction_target, sep = "-"))
      m2_rowind <- which(lc_df$name == paste(m2_name, prediction_target, sep = "-"))
      
     	lc_df[rowind, ] <- rep(NA, ncol(lc_df))
      lc_df$name[rowind] <- paste0(m1_name, "-", m2_name, "-", prediction_target)
     	lc_df$target[rowind] <- prediction_target
     	lc_df[rowind, coef_cols] <- lc_df[m1_rowind, coef_cols] - lc_df[m2_rowind, coef_cols]
    }
  }
}

contrast_row_inds <- seq(from = length(model_row_inds) + 1, to = nrow(lc_df))

## average performance of each model across all three prediction targets
for(fit_method_ind in seq_len(length(all_models))) {
  rowind <- rowind + 1
  
  m_name <- all_models[fit_method_ind]

  m_rowinds <- which(lc_df$model == m_name)

 	lc_df[rowind, ] <- rep(NA, ncol(lc_df))
 	lc_df$model[rowind] <- m_name
  lc_df$name[rowind] <- paste0(m_name, "-grand_mean")
 	lc_df[rowind, coef_cols] <- apply(lc_df[m_rowinds, coef_cols], 2, mean)
}

#lc_df <- lc_df[c(1:9, 136:144), ]

lc_df$name <- factor(lc_df$name, levels = unique(lc_df$name))

K_mat <- as.matrix(lc_df[, coef_cols])

# get point estimates
lc_df$pt_est <- as.vector(K_mat %*% matrix(fixef(results_fit_before_target)))

# get familywise CIs
confint_rows <- seq_len(nrow(lc_df))
lc_df$fam_CI_lb <- NA
lc_df$fam_CI_ub <- NA
fam_CI_obj <- glht(results_fit_before_target, linfct = K_mat[confint_rows, ])
temp <- confint(fam_CI_obj)$confint
lc_df$fam_CI_lb[confint_rows] <- temp[, 2]
lc_df$fam_CI_ub[confint_rows] <- temp[, 3]

# get individual CIs
lc_df$ind_CI_lb <- NA
lc_df$ind_CI_ub <- NA
for(rowind in confint_rows) {
	ind_CI_obj <- glht(results_fit_before_target, linfct = K_mat[rowind, , drop = FALSE])
	temp <- confint(ind_CI_obj)$confint
	lc_df$ind_CI_lb[rowind] <- temp[, 2]
	lc_df$ind_CI_ub[rowind] <- temp[, 3]
}


summary_figure_df <-
  lc_df[confint_rows, c("model", "target", "pt_est", "fam_CI_lb", "fam_CI_ub", "ind_CI_lb", "ind_CI_ub")]

summary_figure_df$model[summary_figure_df$model == "kde"] <- "KDE"
summary_figure_df$model[summary_figure_df$model == "kcde"] <- "KCDE"
summary_figure_df$model[summary_figure_df$model == "sarima"] <- "SARIMA"
summary_figure_df$model[summary_figure_df$model == "equal_weights"] <- "EW"
summary_figure_df$model[summary_figure_df$model == "em_stacking"] <- "CW"
summary_figure_df$model[summary_figure_df$model == "xgb_stacking_unregularized"] <- "FW-wu"
summary_figure_df$model[summary_figure_df$model == "xgb_stacking_reg_w"] <- "FW-reg-w"
summary_figure_df$model[summary_figure_df$model == "xgb_stacking_reg_wu"] <- "FW-reg-wu"
summary_figure_df$model[summary_figure_df$model == "xgb_stacking_reg_wui"] <- "FW-reg-wui"
summary_figure_df$model <- factor(summary_figure_df$model,
  levels = c("KDE", "KCDE", "SARIMA",
    "EW", "CW", "FW-wu",
    "FW-reg-w", "FW-reg-wu", "FW-reg-wui"))

summary_figure_df$target[summary_figure_df$target == "onset"] <- "Onset Timing"
summary_figure_df$target[summary_figure_df$target == "peak_inc"] <- "Peak Incidence"
summary_figure_df$target[summary_figure_df$target == "peak_week"] <- "Peak Timing"
summary_figure_df$target <- factor(summary_figure_df$target,
  levels = c("Onset Timing", "Peak Timing", "Peak Incidence"))
summary_figure_df$prediction_target <- summary_figure_df$target


awes_path <- find.package("awes")

preds <- assemble_predictions(
  preds_path = file.path(awes_path, "evaluation/test-predictions"),
  models = c("kde", "kcde", "sarima", "equal_weights", "em_stacking", "xgb_stacking_unregularized", "xgb_stacking_reg_w", "xgb_stacking_reg_wu", "xgb_stacking_reg_wui"),
  prediction_targets = c("onset", "peak_week", "peak_inc"),
  prediction_types = "log_score"
) %>%
  filter(analysis_time_season_week %in% 10:40) %>%
  gather_("prediction_target", "log_score",
    c("onset_log_score", "peak_week_log_score", "peak_inc_log_score")) %>%
  mutate(
    prediction_target = substr(prediction_target, 1, nchar(prediction_target) - 10)
  )

preds$model[preds$model == "kde"] <- "KDE"
preds$model[preds$model == "kcde"] <- "KCDE"
preds$model[preds$model == "sarima"] <- "SARIMA"
preds$model[preds$model == "equal_weights"] <- "EW"
preds$model[preds$model == "em_stacking"] <- "CW"
preds$model[preds$model == "xgb_stacking_unregularized"] <- "FW-wu"
preds$model[preds$model == "xgb_stacking_reg_w"] <- "FW-reg-w"
preds$model[preds$model == "xgb_stacking_reg_wu"] <- "FW-reg-wu"
preds$model[preds$model == "xgb_stacking_reg_wui"] <- "FW-reg-wui"
preds$model <- factor(preds$model,
  levels = c("KDE", "KCDE", "SARIMA",
    "EW", "CW", "FW-wu",
    "FW-reg-w", "FW-reg-wu", "FW-reg-wui"))

preds$prediction_target[preds$prediction_target == "onset"] <- "Onset Timing"
preds$prediction_target[preds$prediction_target == "peak_inc"] <- "Peak Incidence"
preds$prediction_target[preds$prediction_target == "peak_week"] <- "Peak Timing"
preds$prediction_target <- factor(preds$prediction_target,
  levels = c("Onset Timing", "Peak Timing", "Peak Incidence"))

p <- ggplot() +
  geom_boxplot(aes(x = model, y = log_score),
    color = "#CCCCCC",
    data = preds) +
  geom_point(aes(x = model, y = log_score),
#    colour = "red",
    colour = "#CCCCCC",
    shape = "+",
    size = 5,
    position = position_jitter(width = 1, height = 0),
    data = preds %>%
      filter(is.infinite(log_score)) %>%
      mutate(log_score = -15)) +
  geom_point(aes(x = model, y = pt_est),
    data = summary_figure_df[model_row_inds, ]) +
  geom_errorbar(aes(x = model, ymin = fam_CI_lb, ymax = fam_CI_ub),
    data = summary_figure_df[model_row_inds, ],
    width = 0.7) +
#  geom_errorbar(aes(x = model, ymin = ind_CI_lb, ymax = ind_CI_ub),
#    data = summary_figure_df[model_row_inds, ],
#    width = 0.2) +
  facet_wrap(~ prediction_target, ncol = 1) +
  xlab("Model") +
  ylab("Log Score") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

suppressWarnings(print(p))
```


```{r test_phase_log_scores_summary_v1, echo=FALSE, cache=TRUE, fig.height=8, fig.cap="\\label{fig:test_phase_log_score_boxplot}Log scores across all regions, seasons, and season weeks represented in box plots.  Log scores of negative infinity are represented with a cross at -15."}
awes_path <- find.package("awes")

preds <- assemble_predictions(
  preds_path = file.path(awes_path, "evaluation/test-predictions"),
  models = c("kde", "kcde", "sarima", "equal_weights", "em_stacking", "xgb_stacking_unregularized", "xgb_stacking_reg_w", "xgb_stacking_reg_wu", "xgb_stacking_reg_wui"),
  prediction_targets = c("onset", "peak_week", "peak_inc"),
  prediction_types = "log_score"
) %>%
  filter(analysis_time_season_week %in% 10:40) %>%
  gather_("prediction_target", "log_score",
    c("onset_log_score", "peak_week_log_score", "peak_inc_log_score")) %>%
  mutate(
    prediction_target = substr(prediction_target, 1, nchar(prediction_target) - 10)
  )

preds$model[preds$model == "kde"] <- "KDE"
preds$model[preds$model == "kcde"] <- "KCDE"
preds$model[preds$model == "sarima"] <- "SARIMA"
preds$model[preds$model == "equal_weights"] <- "EW"
preds$model[preds$model == "em_stacking"] <- "CW"
preds$model[preds$model == "xgb_stacking_unregularized"] <- "FW-wu"
preds$model[preds$model == "xgb_stacking_reg_w"] <- "FW-reg-w"
preds$model[preds$model == "xgb_stacking_reg_wu"] <- "FW-reg-wu"
preds$model[preds$model == "xgb_stacking_reg_wui"] <- "FW-reg-wui"
preds$model <- factor(preds$model,
  levels = c("KDE", "KCDE", "SARIMA",
    "EW", "CW", "FW-wu",
    "FW-reg-w", "FW-reg-wu", "FW-reg-wui"))

preds$prediction_target[preds$prediction_target == "onset"] <- "Onset Timing"
preds$prediction_target[preds$prediction_target == "peak_inc"] <- "Peak Incidence"
preds$prediction_target[preds$prediction_target == "peak_week"] <- "Peak Timing"
preds$prediction_target <- factor(preds$prediction_target,
  levels = c("Onset Timing", "Peak Timing", "Peak Incidence"))

p <- ggplot() +
  geom_boxplot(aes(x = model, y = log_score),
    data = preds) +
  geom_point(aes(x = model, y = log_score),
    colour = "red",
    shape = "+",
    size = 5,
    position = position_jitter(width = 1, height = 0),
    data = preds %>%
      filter(is.infinite(log_score)) %>%
      mutate(log_score = -15)) +
  facet_wrap(~ prediction_target, ncol = 1) +
  xlab("Model") +
  ylab("Log Score") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

suppressWarnings(print(p))
```


```{r test_phase_log_scores_by_season_heatmap_rank_rounded, echo=FALSE, cache=TRUE, fig.height=8, fig.cap="\\label{fig:test_phase_log_scores_heatmap}Model performance ranked by mean log score within each of the five test seasons for predictions made before the target (season onset or peak) occurred.  Averages are taken across all regions."}
awes_path <- find.package("awes")

region_season_obs_quantities <- flu_data %>%
  select_(.dots = c("region", "season")) %>%
  distinct() %>%
  filter(season %in% paste0(2011:2015, "/", 2012:2016)) %>%
  mutate(
    observed_onset_week = NA,
    observed_peak_week = NA
  )

for(rs_row in seq_len(nrow(region_season_obs_quantities))) {
  temp <- get_observed_seasonal_quantities(
    data = flu_data[flu_data$region == region_season_obs_quantities$region[rs_row], , drop = FALSE],
    season = region_season_obs_quantities$season[rs_row],
    first_CDC_season_week = 10,
    last_CDC_season_week = 42,
    onset_baseline =
      get_onset_baseline(region = region_season_obs_quantities$region[rs_row],
        season = region_season_obs_quantities$season[rs_row]),
    incidence_var = "weighted_ili",
    incidence_bins = data.frame(
      lower = c(0, seq(from = 0.05, to = 12.95, by = 0.1)),
      upper = c(seq(from = 0.05, to = 12.95, by = 0.1), Inf)),
    incidence_bin_names = as.character(seq(from = 0, to = 13, by = 0.1))
  )
  
  region_season_obs_quantities$observed_onset_week[rs_row] <-
    temp$observed_onset_week
  region_season_obs_quantities$observed_peak_week[rs_row] <-
    temp$observed_peak_week[1]
}

region_season_obs_quantities$observed_onset_week[
  region_season_obs_quantities$observed_onset_week == "none"] <- 42
region_season_obs_quantities <- region_season_obs_quantities %>%
  transmute(
    region = gsub(" ", "", region),
    analysis_time_season = season,
    observed_onset_week = as.numeric(observed_onset_week),
    observed_peak_week = observed_peak_week
  )

all_models <- c("kde", "kcde", "sarima", "equal_weights", "em_stacking", "xgb_stacking_unregularized", "xgb_stacking_reg_w", "xgb_stacking_reg_wu", "xgb_stacking_reg_wui")
all_targets <- c("onset", "peak_week", "peak_inc")
preds <- assemble_predictions(
  preds_path = file.path(awes_path, "evaluation/test-predictions"),
  models = all_models,
  prediction_targets = all_targets,
  prediction_types = "log_score"
) %>%
  filter(analysis_time_season_week %in% 10:40) %>%
  gather_("prediction_target", "log_score",
    c("onset_log_score", "peak_week_log_score", "peak_inc_log_score")) %>%
  mutate(
    prediction_target = substr(prediction_target, 1, nchar(prediction_target) - 10),
    score = exp(log_score)
  )

preds$log_score[is.infinite(preds$log_score)] <- -10
preds <- preds %>%
  left_join(region_season_obs_quantities, by = c("region", "analysis_time_season")) %>%
  mutate(
    before_onset = (analysis_time_season_week < observed_onset_week),
    before_peak = (analysis_time_season_week < observed_peak_week))

preds$before_target_date <- ifelse(
  preds$prediction_target == "onset",
  c("on or after\ntarget date", "before\ntarget date")[preds$before_onset + 1],
  c("on or after\ntarget date", "before\ntarget date")[preds$before_peak + 1]
)

preds$model[preds$model == "kde"] <- "KDE"
preds$model[preds$model == "kcde"] <- "KCDE"
preds$model[preds$model == "sarima"] <- "SARIMA"
preds$model[preds$model == "equal_weights"] <- "EW"
preds$model[preds$model == "em_stacking"] <- "CW"
preds$model[preds$model == "xgb_stacking_unregularized"] <- "FW-wu"
preds$model[preds$model == "xgb_stacking_reg_w"] <- "FW-reg-w"
preds$model[preds$model == "xgb_stacking_reg_wu"] <- "FW-reg-wu"
preds$model[preds$model == "xgb_stacking_reg_wui"] <- "FW-reg-wui"
preds$model <- factor(preds$model,
  levels = c("KDE", "KCDE", "SARIMA",
    "EW", "CW", "FW-wu",
    "FW-reg-w", "FW-reg-wu", "FW-reg-wui"))

preds$prediction_target[preds$prediction_target == "onset"] <- "Onset Timing"
preds$prediction_target[preds$prediction_target == "peak_inc"] <- "Peak Incidence"
preds$prediction_target[preds$prediction_target == "peak_week"] <- "Peak Timing"
preds$prediction_target <- factor(preds$prediction_target,
  levels = c("Onset Timing", "Peak Timing", "Peak Incidence"))

preds <- preds %>%
  mutate(
    region = factor(region),
    analysis_time_season = factor(analysis_time_season)
  )

res <- mean(log_score ~ model + prediction_target + analysis_time_season,
  data = preds[preds$before_target_date == "before\ntarget date", ])
temp <- strsplit(names(res), ".", fixed = TRUE) %>%
  unlist() %>%
  matrix(ncol = 3, byrow = TRUE)
res <- cbind(temp, res) %>%
  as.data.frame(stringsAsFactors = FALSE) %>%
  `colnames<-`(c("model", "prediction_target", "season", "mean_log_score")) %>%
  `rownames<-`(NULL) %>%
  group_by_(.dots = c("prediction_target", "season")) %>%
  mutate(mean_log_score = as.numeric(mean_log_score),
    rank = rank(-1 * round(as.numeric(mean_log_score), 2)))
res$prediction_target <- factor(res$prediction_target,
  levels = c("Onset Timing", "Peak Timing", "Peak Incidence"))
res$model <- factor(res$model,
  levels = c("KDE", "KCDE", "SARIMA",
    "EW", "CW", "FW-wu",
    "FW-reg-w", "FW-reg-wu", "FW-reg-wui"))

overall_rank <- res %>% group_by(prediction_target, model) %>%
    summarize(
        season="Average Rank",
#        mean_log_score = mean(mean_log_score),
#        mean_log_score = "",
        mean_log_score = format(round(mean(as.numeric(rank)), 2), nsmall=2), # gets printed in table cell
        rank = round(mean(as.numeric(rank)), 2)
        ) %>% ungroup()

minimum_rank <- res %>% group_by(prediction_target, model) %>%
    summarize(
        season="Lowest Rank",
#        mean_log_score = mean(mean_log_score),
#        mean_log_score = "",
        mean_log_score = format(round(max(as.numeric(rank)), 2), nsmall=2), # gets printed in table cell
        rank = round(max(as.numeric(rank)), 2)
        ) %>% ungroup()

overall_log_score <- res %>% group_by(prediction_target, model) %>%
    summarize(
        season="Average Log Score",
        mean_log_score = format(round(mean(mean_log_score), 2), nsmall=2)
#        rank = NA
#        mean_log_score = "",
#        rank = factor(round(mean(as.numeric(rank))), levels=1:9)
    ) %>%
  ungroup() %>%
  group_by(prediction_target) %>%
  mutate(rank = rank(-1 * as.numeric(mean_log_score, 2))) %>%
  ungroup()

minimum_log_score <- res %>% group_by(prediction_target, model) %>%
    summarize(
        season="Lowest Log Score",
        mean_log_score = format(round(min(mean_log_score), 2), nsmall=2)
#        rank = NA
#        mean_log_score = "",
#        rank = factor(round(mean(as.numeric(rank))), levels=1:9)
    ) %>%
  ungroup() %>%
  group_by(prediction_target) %>%
  mutate(rank = rank(-1 * as.numeric(mean_log_score, 2))) %>%
  ungroup()

res_with_overall <- bind_rows(
  res %>%
    mutate(mean_log_score = format(round(mean_log_score,2), nsmall=2)),
  overall_rank,
  minimum_rank,
  overall_log_score,
  minimum_log_score)

ggplot(data = res_with_overall, aes(x = model, y = season)) +
  geom_tile(aes(fill = rank)) +
  geom_text(aes(label=mean_log_score)) +
  facet_wrap(~ prediction_target, ncol = 1) +
  scale_fill_gradient2("Model\nRank",
    breaks = 1:9,
#    labels = as.character(1:9),
    low = "#2166ac",
    mid = "#f7f7f7",
    high = "#b2182b",
    midpoint = 5) +
#    values = rev(c("#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac"))) +
  xlab("Model") +
  ylab("Season") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```



<!--#### Fig: test phase summary: 3 row-facets, one for each target, each model (color?) year (x) is a point with MAE (y) \label{fig:test-phase-MAE}-->


# Discussion

In this work we have examined the potential for ensemble methods to improve infectious disease predictions. 
We explored a nested series of ensemble methods, focusing on methods that computed weighted averages of predictive distributions for seasonal targets of public health interest, such as the peak intensity of the outbreak and the timing of both season onset and peak.
The methods we examined ranged from using equal model weights to more complex schemes with weights that varied as functions of multiple covariates. 
These ensemble methods achieved overall performance that was about as good as the individual component models, with increased stability in model performance across different seasons.

Increased stability in predictive accuracy can provide decision makers with more confidence when using predictions as inputs to set policy. 
For example, if a single model does well in most seasons but occasionally fails badly, planning decisions may be negatively impacted in those failing years. 
This may be particularly important in a public health setting where the events that are most important to get right are those relatively rare cases when incidence is much larger than usual or the season timing is earlier or later than usual. 
This reduction in variability of model performance achieved by ensemble methods is therefore important for ensuring that our predictions are reliable under a variety of conditions.

The different ensemble specifications we considered had similar average performance over the test phase, when all models were making prospective, out-of-sample predictions. 
However, there were differences among the ensemble models in terms of their consistency across different seasons. 
For all three prediction targets, worst-case log scores and the worst-case model ranking across the five test seasons were slightly lower for the constant-weight (\textbf{CW}) ensemble than they were for the ensemble with smoothed model weights varying by week (\textbf{FW-reg-w}).
There were not appreciable or consistent differences among the feature-weighted models using different feature sets, indicating that including model uncertainty and recent observations of disease incidence did not add much more information about relative model performance than was available from the week of the season in which predictions were generated. 
The equally weighted ensemble model had lower mean log scores than the \textbf{CW} and \textbf{FW-reg-w} ensembles for all three prediction targets, but had better worst-case performance than the other ensembles for predictions of peak timing. 
Synthesizing these observations, no ensemble was uniformly better than the others, but the \textbf{FW-reg-w} method had good average and worst-case performance across all test phase seasons and prediction targets.

The feature-weighted ensemble models presented in this article use a novel scheme to estimate feature-dependent model weights that sum to 1 and are therefore suitable for use in combining predictive distributions. 
This general method could be applied to combine distribution estimates in any context, and is not limited to time-series or infectious disease applications.
Furthermore, comparing an implementation of the feature-weighting that smoothed the model weights to one that did not showed consistent improvements in model performance. 
This result suggests that future work on feature-weighted ensemble implementations should consider regularized estimation.

<!--In future applications to infectious disease, it may be possible to use a framework like feature-weighed stacking to identify epidemiological features that are responsible for shifting the transmission dynamics from one regime to another.
For example, there may be circumstances where measurable characteristics of the dynamical system, such as patterns of weather or population movement, could provide valuable information about future transmission dynamics. 
Therefore, examining the weights estimated for specific subsets of component models that contain data on these characteristics could provide insights into the drivers of the epidemiological dynamics of the system. -->

Infectious disease predictions are only useful to public health officials if they are communicated effectively in real time.  Predictions from an early version of the \textbf{FW-reg-w} model were updated weekly during the 2016/2017 influenza season and disseminated through an interactive website at https://reichlab.io/flusight/.

<!--[[TODO: Discuss how varying some of these regularization parameters can give the simpler EW and dEM models??  Or ignore?  Or defer to supplement?]]-->

A central challenge of working with infectious disease data sets is the limited number of years of data available for model estimation and evaluation.  We have used approximately one fourth of our data set for model evaluation, which left us with only 14 seasons of training data and 5 seasons of testing data.  Additionally, we had fewer than 14 seasons of leave-one-season-out predictions to use in estimating the model weighting functions for the \textbf{FW} ensemble methods because the \textbf{SARIMA} model required unobserved seasonally lagged incidence to make predictions for the first few seasons in the training phase.  This small sample size may have negatively impacted our ability to estimate the weighting functions.  We also have a small effective sample size for detecting differences in average model performance in the test phase because of the high degree of correlation in model log scores for the same prediction target in different weeks and regions within the same season.

Another limitation of this work is the small selection of component models used.  Theoretical results and applications have demonstrated that ensemble methods are most effective when using a diverse set of component models \cite{polikar2006ensemble}.  In our study, the \textbf{KCDE} and \textbf{SARIMA} component models are similar in that they both use seasonal terms and observations of recent incidence to (though we note that these two models tended to perform well in different seasons, as illustrated in Fig \ref{fig:test_phase_log_scores_heatmap}).  Increased component model diversity could yield improved ensemble performance; this could be achieved either through inclusion of different model structures (such as agent-based or mechanistic models) or different covariates (such as spatial effects, weather, or circulating strains of a disease).

Our exploration of feature-weighted ensembles is also limited by the relatively restricted feature sets we used for the weighting functions.  We selected a few features based on exploratory analysis of the training phase results, and set all ensemble model formulations before obtaining any predictions for the test phase.  It is possible that other weighting features not considered in this work may be more informative than those we have used.  Some ideas for weighting covariates to use in future work include the largest incidence so far this season; the onset threshold; alternative summaries of the predictive distributions from the component models such as the probability at the mode or the modal value; the predominant flu strain; or the distribution of incidence in age groups.

This work provides a rigorous and comprehensive evaluation of ensemble methods for averaging probabilistic  predictions for features of infectious disease outbreaks. 
A range of models, both single component models and ensemble models that combined component model predictions, demonstrated the ability to make more accurate predictions than a seasonal average baseline model.
Additionally, systematic comparisons of simple and complex prediction models highlight a crucial added value of ensemble modeling, namely increased stability and consistency of model performance across seasons.
Continued investigation, application, and innovation is necessary to strengthen our understanding of how to best leverage combinations of models to assist decision makers in fields, such as public health and infectious disease surveillance, that require data-driven rapid response.

# Acknowledgments

This work was supported by Award Number R35GM119582 from the National Institute Of General Medical Sciences and Defense Advanced Projects Research Agency Young Faculty Award Number Dl6AP00144. The content is solely the responsibility of the authors and does not necessarily represent the official views of the National Institute Of General Medical Sciences, the National Institutes of Health, or the Defense Advanced Projects Research Agency.  The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.

```{r test-phase-plot-summary, eval=FALSE, echo = FALSE}
## plots created for MIDAS meeting evaluation
target_to_plot <- "Peak Incidence"
preds_to_plot <- filter(preds, 
                        prediction_target==target_to_plot, 
                        region %in% c("National", "Region1", "Region7"))

## three reds, blues and blacks
# cols <- c(RColorBrewer::brewer.pal(4, "Reds")[2:4],
#           RColorBrewer::brewer.pal(9, "Blues")[2:9])
cols <- c("KDE" = RColorBrewer::brewer.pal(4, "Reds")[2],
          "KCDE" = RColorBrewer::brewer.pal(4, "Reds")[3],
          "SARIMA" = RColorBrewer::brewer.pal(4, "Reds")[4],
          "EW" = RColorBrewer::brewer.pal(9, "Blues")[3],
          "CW" = RColorBrewer::brewer.pal(9, "Blues")[3],
          "FW-wu" = RColorBrewer::brewer.pal(9, "Blues")[3],
          "FW-reg-w" = RColorBrewer::brewer.pal(9, "Blues")[9],
          "FW-reg-wu" = RColorBrewer::brewer.pal(9, "Blues")[3],
          "FW-reg-wui" = RColorBrewer::brewer.pal(9, "Blues")[3])
ggplot(preds_to_plot, aes(x=analysis_time_season_week, y=log_score, color=model)) +
    geom_line(alpha=.8) + scale_color_manual(values=cols) +
    facet_grid(region~analysis_time_season) +
    xlab("season week") + ylab("log score") +
    ggtitle(target_to_plot)
```


\nolinenumbers

\bibliographystyle{plos2015}
\bibliography{feature-weighted-ensembles}
