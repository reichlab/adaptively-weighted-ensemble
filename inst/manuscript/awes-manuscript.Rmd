---
output:
  pdf_document:
    citation_package: none
    fig_caption: true
    keep_tex: true
documentclass: article
classoption: 10pt,letterpaper
geometry: top=0.85in,left=2.75in,footskip=0.75in
date: ""
header-includes:
   - \usepackage[nomarkers, nolists, figuresonly]{endfloat}
   - \usepackage{amsmath,amssymb}
   - \usepackage{changepage}
   - \usepackage{textcomp,marvosym}
   - \usepackage{cite}
   - \usepackage{nameref,hyperref}
   - \usepackage[right]{lineno}
   - \usepackage{microtype}
   - \DisableLigatures[f]{encoding = *, family = * }
   - \usepackage[table]{xcolor}
   - \usepackage{array}
   - \newcolumntype{+}{!{\vrule width 2pt}}
   - \newlength\savedwidth
   - \newcommand\thickcline[1]{ \noalign{\global\savedwidth\arrayrulewidth\global\arrayrulewidth 2pt} \cline{#1}  \noalign{\vskip\arrayrulewidth} \noalign{\global\arrayrulewidth\savedwidth}}
   - \newcommand\thickhline{\noalign{\global\savedwidth\arrayrulewidth\global\arrayrulewidth 2pt} \hline \noalign{\global\arrayrulewidth\savedwidth}}
   - \usepackage{setspace}
   - \doublespacing
   - \raggedright
   - \setlength{\parindent}{0.5cm}
   - \textwidth 5.25in
   - \textheight 8.75in
   - \usepackage[aboveskip=1pt,labelfont=bf,labelsep=period,justification=raggedright,singlelinecheck=off]{caption}
   - \renewcommand{\figurename}{Fig}
   - \makeatletter
   - \renewcommand{\@biblabel}[1]{\quad#1.}
   - \makeatother
   - \input{GrandMacros.tex}
   - \usepackage{booktabs}
   - \renewcommand{\familydefault}{cmss}
   - \usepackage{lastpage,fancyhdr,graphicx}
   - \usepackage{epstopdf}
   - \pagestyle{myheadings}
   - \pagestyle{fancy}
   - \fancyhf{}
   - \setlength{\headheight}{27.023pt}
   - \rfoot{\thepage/\pageref{LastPage}}
   - \renewcommand{\footrule}{\hrule height 2pt \vspace{2mm}}
   - \fancyheadoffset[L]{2.25in}
   - \fancyfootoffset[L]{2.25in}
   - \usepackage{color, soul}
   - \soulregister\cite7
   - \soulregister\ref7
   - \soulregister\pageref7
   - \newcommand{\newtext}[1]{\hl{#1}}
bibliography: feature-weighted-ensembles.bib
---

   <!-- - \lhead{\includegraphics[width=2.0in]{PLOS-submission-eps-converted-to.pdf}} -->
   <!-- - \lfoot{\sf PLOS} -->

```{r init, include = FALSE}
library(plyr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(grid)
library(awes)
library(mosaic)
library(gridExtra)
library(cowplot)
library(nlme)
library(multcomp)
library(doMC)
```

\vspace*{0.2in}

\begin{flushleft}
{\Large
\textbf\newline{Prediction of infectious disease epidemics via weighted density ensembles} % Please use "sentence case" for title and headings (capitalize only the first word in a title (or heading), the first word in a subtitle (or subheading), and any proper nouns).
}
\newline
% Insert author names, affiliations and corresponding author email (do not include titles, positions, or degrees).
\\
Evan L. Ray\textsuperscript{*},
Nicholas G. Reich
\\
\bigskip
Department of Biostatistics and Epidemiology, University of Massachusetts, Amherst, MA, USA
\\

\bigskip

% Use the asterisk to denote corresponding authorship and provide email address in note below.
* elray@umass.edu

\end{flushleft}

# Abstract

Accurate and reliable predictions of infectious disease dynamics can be valuable to public health organizations that plan interventions to decrease or prevent disease transmission.
A great variety of models have been developed for this task, using different model structures, covariates, and targets for prediction.
Experience has shown that the performance of these models varies; some tend to do better or worse in different seasons or at different points within a season.
Ensemble methods combine multiple models to obtain a single prediction that leverages the strengths of each model.
We considered a range of ensemble methods that each form a predictive density for a target of interest as a weighted sum of the predictive densities from component models.
In the simplest case, equal weight is assigned to each component model; in the most complex case, the weights vary with the region, prediction target, week of the season when the predictions are made, a measure of component model uncertainty, and recent observations of disease incidence.
We applied these methods to predict measures of influenza season timing and severity in the United States, both at the national and regional levels, using three component models.
We trained the models on retrospective predictions from 14 seasons (1997/1998 - 2010/2011) and evaluated each model's prospective, out-of-sample performance in the five subsequent influenza seasons.
In this test phase, the ensemble methods showed \newtext{average} performance that was similar to the best of the component models, but offered more consistent performance across seasons than the component models.
Ensemble methods offer the potential to deliver more reliable predictions to public health decision makers.

# Author Summary

Public health agencies such as the Centers for Disease Control would like to have as much information as possible when planning interventions intended to reduce and prevent the spread of infectious disease.  For instance, accurate and reliable predictions of the timing and severity of the influenza season could help with planning how many influenza vaccine doses to produce and by what date they will be needed.  Many different mathematical and statistical models have been proposed to model influenza and other infectious diseases, and these models have different strengths and weaknesses.  In particular, one or another of these model specifications is often better than the others in different seasons, at different times within the season, and for different prediction targets (such as different measures of the timing or severity of the influenza season).  In this article, we explore ensemble methods that combine predictions from multiple “component” models.  We find that these ensemble methods do about as well as the best of the component models in terms of aggregate performance across multiple seasons, but that the ensemble methods have more consistent performance across different seasons.  This improved consistency is valuable for planners who need predictions that can be trusted under all circumstances.

\linenumbers

# Introduction

The practice of combining predictions from different models has been used for decades by climatologists and geophysical scientists.
These methods have subsequently been adapted and extended by statisticians and computer scientists in diverse areas of scientific inquiry.
In recent years, these "ensemble" forecasting approaches frequently have been among the top methods used in prediction challenges across a wide range of applications.

Ensembles are a natural choice for noisy, complex, and interdependent systems that evolve over time.
In these settings, no one model is likely to be able to capture and predict the full set of complex relationships that drive future observations from a particular system of interest.
Instead "specialist" or "component" models can be relied on to capture distinct features or signals from a system and, when combined, represent a nearly complete range of possible outcomes.
In this work, we develop and compare a collection of ensemble methods for combining predictive densities.
This enables us to quantify the improvement in predictions achieved by using ensemble methods with varying levels of complexity.

To illustrate these ensemble methods, we present time-series forecasts for infectious disease, specifically for influenza in the United States.
The international significance of emerging epidemic threats in recent decades has highlighted the importance of understanding and being able to predict infectious disease dynamics.
With the revolution in science driven by the promise of "big" and real-time data, there is an increased focus on and hope for using statistics to inform public health policy and decision-making in ways that could mitigate the impact of future outbreaks.
Some of the largest public health agencies in the world, including the US Centers for Disease Control and Prevention (CDC) have openly endorsed using models to inform decision making, saying "with models, decision-makers can look to the future with confidence in their ability to respond to outbreaks and public health emergencies" \cite{cdc-decisions-2016}.

\newtext{There is a large literature on prediction methods for influenza.
We will give a brief overview of this literature here, and refer the reader to
Chretien \mbox{\etal} \mbox{\cite{chretien2014influenza}} and Nsoesie \mbox{\etal} \mbox{\cite{nsoesie2014systematic}}
for more comprehensive reviews; additionally, \mbox{\cite{biggerstaff2016resultsCDC20132014InfluenzaChallenge}} present the results of a recent influenza prediction challenge run by the US centers for disease control where many of these models were employed.
Infectious disease prediction methods can be broadly grouped into three categories:
agent-based models, compartmental models \mbox{\cite{Shaman2012, shaman2013realTimeInfluenza, shaman2015improvedInfluenzaEnsembleConsecutivePredictions, yang2014comparisonFilteringInfluenza, yang2015forecastingInfluenzaHongKong, yang2016forecasting}}, and regression-based time series models that
may include auto-regressive and seasonal terms \mbox{\cite{chakraborty2014forecastingILIEnsemble}}.
Additionally, these models may use a variety of different data sources and covariates to inform their predictions,
including historical values of the disease incidence time series \mbox{\cite{chakraborty2014forecastingILIEnsemble, Shaman2012, shaman2013realTimeInfluenza, shaman2015improvedInfluenzaEnsembleConsecutivePredictions, yang2014comparisonFilteringInfluenza, yang2015forecastingInfluenzaHongKong, yang2016forecasting}};
data derived from internet sources such as web searches, wikipedia page views, and twitter \mbox{\cite{chakraborty2014forecastingILIEnsemble, hickmann2015forecastingInfluenzaWikipedia, paul2014twitterInfluenzaForecasting,  santillana2015combiningSearchTwitterInfluenza, Shaman2012, shaman2013realTimeInfluenza, yang2014comparisonFilteringInfluenza}};
and climatological variables \mbox{\cite{chakraborty2014forecastingILIEnsemble, Shaman2012, shaman2013realTimeInfluenza, yang2014comparisonFilteringInfluenza, yang2016forecasting}}, among others.
These models may generate either point predictions, possibly along with associated predictive intervals,
or full predictive distributions.}

\newtext{The ensemble methods that we explore in the present work are designed to combine predictions from multiple models, which could use a variety of different model structures and covariates to generate predictions.}
Development of the methods presented in this manuscript was motivated by the observation that certain prediction models for infectious disease consistently performed better than other models at certain times of year.
We observed in previous research that early in the influenza season, simple models of historical incidence often outperformed more standard time-series prediction models such as a seasonal auto-regressive integrated moving average (SARIMA) model \cite{rayInPressKCDE}.
However, in the middle of the season, the time-series models showed improved accuracy.
We set out to determine whether ensemble methods could use this information about past model performance to improve predictions.

A large number of ensemble methods have been developed for a diverse array of tasks including regression, classification, and density estimation.  These methods are broadly similar in that they combine results from multiple component models.  However, details differ between ensemble methods.  We suggest Polikar \cite{polikar2006ensemble} for a review of ensemble methods; many of these are also discussed in detail in Hastie \etal \cite{Hastie2011}.

While there are many different methods for combining models, all ensemble models discussed in this paper use an approach called stacking \newtext{\mbox{\cite{Wolpert1992}}}.
In this approach, each of the component models is trained separately in a first stage, and cross-validated measures of performance of those component models are obtained.
Then, in a second stage, a stacking model is trained using the cross-validated performance measures to learn how to optimally combine predictive densities from the component models.
The specific implementations of stacking that we use obtain the final predictive density as a weighted sum of the component predictive densities, where the weights may depend on covariates.
We refer to this approach generally as a ''weighted density ensemble'' approach to prediction.
Several variations on this strategy have been explored in the literature previously \cite{smyth1999stackingDensityEstimators,  rigollet2007linearconvexaggregationdensity, ganti2011cake}.  However, other ensemble methods for density estimation have also been developed.  For example, Rosset and Segal \cite{rosset2002boosting} develop a boosting method in which the component models are estimated sequentially, with results from earlier models affecting estimation of later models.

In structured prediction settings such as time series forecasting, ensemble methods may benefit from taking advantage of the data structure.  For example, it may be the case that different models offer a better representation of the data at different points in time.  A common idea in these settings is to use model weights that change over time.  For instance, model weights may vary as a function of how well each model did in recent predictions \cite{herbster1998tracking} or by using a more formal graphical structure such as a hidden Markov model to track which component model is most likely to have generated new observations as they arise over time \cite{yamanishi2007dynamicmodelselection, cortes2014ensembleStructuredPrediction}.  It is also possible to combine the component models with weights that depend on observed covariates or features \cite{Sill2009}.  For example, in an ensemble for a user recommendation system, Jahrer \etal \cite{jahrer2010Netflix} allowed model weights to depend on a variety of features including the time that a user submitted a rating.

Using component models that generate predictive densities for outcomes of interest, we have implemented a series of ensembles using different methods for choosing the weights for each model.
Specifically, we compare three different approaches.
The first approach simply takes an equally weighted average of all models.
The second approach estimates constant but not necessarily equal weights for each model.
The third approach is a novel method for determining model weights based on features of the system at the time predictions are made.
The overarching goal of this study is to create a systematic comparison between ensemble methods to study the benefits of increasing complexity in ensemble weighting schemes.

We are aware of \newtext{two} previous article\newtext{s} that developed ensemble methods for infectious disease prediction.
Yamana \etal \cite{Yamana2016} \newtext{and Chakraborty \mbox{\etal \cite{chakraborty2014forecastingILIEnsemble}} both} developed model stacking framework\newtext{s} that \newtext{are} similar to the second approach outlined above using a constant weight for each component model.
The present article is differentiated from \newtext{this previous} work in that we explore and compare a range of more flexible ensemble methods where the weights depend on observed features.

This paper presents a novel ensemble method that determines optimal model combinations based on (a) observed data at the time predictions are made and (b) aspects of the predictive distributions obtained from the component models.
We refer to models built using this approach as "feature-weighted" ensembles.
This approach fuses aspects of different ensemble methods: it uses model stacking \cite{Wolpert1992} and estimates model weights based on features of the system \cite{Sill2009} using gradient tree boosting \cite{friedman2001greedy}.

Using seasonal influenza outbreaks in the US health regions as a case-study, we developed and applied our ensemble models to predict several attributes of the influenza season at each week during the season.
By illustrating the utility of these approaches to ensemble forecasting in a setting with complex population dynamics, this work highlights the importance of continued innovation in ensemble methodology.

# Methods

This paper presents a comparison of methods for determining weights for weighted density ensembles, applied to forecasting specific features of influenza seasons in the US.
First, we present a description of the influenza data we use in our application and the prediction targets.
Next, we discuss the three component models utilized by the ensemble framework.
We then turn to the ensemble framework itself, describing the different ensemble model specifications used.

## Data and prediction targets

We obtained publicly available data on seasonal influenza activity in the United States between 1997 and 2016 from the \newtext{US} Centers for Disease Control and Prevention (CDC) (Fig \ref{fig:raw-data}).
For each of the 10 Health and Human Services regions in the country in addition to the nation as a whole, the CDC calculates and publishes each week a measure called the weighted influenza-like illness (wILI) index.
The wILI for a particular region is calculated as the average proportion of doctor visits with influenza-like illness for each state in the region, weighted by state population.
During the CDC-defined influenza season (between Morbidity and Mortality Weekly Report week 40 of one year and 20 of the next year), the CDC publishes updated influenza data on a weekly basis.
This includes "current" wILI data from two weeks prior to the reporting date, as well as updates to previously reported numbers as new data becomes available.
For this analysis, we use only the final reported wILI measures to train and predict from our models.
In the early seasons, data were not recorded during the off-season.  Additionally, there were 52 observations in which the reported wILI was zero; these generally occurred near the off-season in early years, and occurred in weeks when only small numbers of health care providers submitted reports to the CDC.  We treated these reported zeros as missing data throughout the analysis.

The CDC defines the influenza season onset as the first of three \newtext{consecutive} weeks of the season for which wILI is greater than or equal to a threshold that is specific to the region and season.
This threshold is the mean percent of patient visits where the patient had ILI during low incidence weeks for that region in the past three seasons, plus two standard deviations \cite{cdc2016}.
The CDC provides historical threshold values for each region going back to the 2007/2008 season \cite{cdc2016-baselines}.
Additionally, we define two other metrics specific to a region-season.
The peak incidence is the maximum observed wILI measured in a season.
The peak week is the week at which the maximum wILI for the season is observed.

Each predictive distribution was represented by probabilities assigned to bins associated with different possible outcomes.
For onset week, the bins are represented by integer values for each possible season week plus a bin for "no onset".
For peak week, the bins are represented by integer values for each possible season week.
For peak incidence, the bins capture incidence rounded to a single decimal place, with a single bin to capture all incidence over \newtext{$12.95$}.
Formally, the incidence bins are as follows: [0, 0.05), [0.05, 0.15), ..., [\newtext{12.85}, \newtext{12.95}), [\newtext{12.95}, $\infty$).
These bins were used in the 2016-2017 influenza prediction contest run by the CDC \cite{cdc2016-contest-guidelines}.

We measure the accuracy of predictive distributions using the log score.
The log score is a proper scoring rule \cite{Gneiting2007}, calculated in our setting as the natural log of the probability assigned to the bin containing the true observation.
Proper scoring rules are preferred for measuring the quality of predictive distributions because the expected score is optimized by the true probabilty distribution.
We note that for peak week, in some region-seasons the same peak incidence was achieved in multiple weeks (after rounding to one decimal place).
In those cases, we calculated the log score as the log of the sum of the probabilities assigned to those weeks; this is consistent with scoring procedures used in the 2016-2017 flu prediction contest run by the CDC \cite{cdc2016-contest-guidelines}.
\newtext{However, the log score is not directly comparable with the score used by the CDC in the prediction contest.
The CDC calculates the score of a prediction as the log of the combined probability assigned to several bins surrounding the realized outcome; this has some benefits, but has the disadvantage that it is not a proper score.
We have opted to use the log score in this work because it is a proper score.}

## Component models
We used three component models to generate probabilistic predictions of the three prediction targets. The first model was a seasonal average model that utilized kernel density estimation (KDE) to estimate a predictive distribution for each target. The second model utilized kernel conditional density estimation (KCDE) and copulas to create a joint predictive distribution for incidence in all remaining weeks of the season, conditional on recent observations of incidence \cite{rayInPressKCDE}.  By calculating appropriate integrals of this joint distribution, we constructed predictive distributions for each of the seasonal targets.  The third model used a standard seasonal auto-regressive integrated moving average (SARIMA) implementation. All models were fit independently on data within each region.

### Kernel Density Estimation (KDE)
The simplest of the component models uses kernel density estimation \cite{silverman1986density} to estimate a distribution for each target based on observed values of that target in previous seasons within the region of interest.
We used Gaussian kernels and the default settings from the `density` function in the `stats` package for R \cite{Rcore2015} to estimate the bandwidth parameter.
For the peak incidence target, we fit to log-transformed observations of historical peak incidence.
For the onset week prediction target, we estimated the probability of no onset as the proportion of region-seasons in all regions in the training phase where no week in the season met the criteria for being a season onset.

To create an empirical predictive distribution of size $N$ from a KDE fit based on a data vector $\by_{1:K}$ (for example, this might be the vector of peak week values from the $K$ training seasons), we first drew $N$ samples with replacement from $\by_{1:K}$, yielding a new vector $\tilde \by_{1:N}$.
We then drew a single psuedo-random deviate from each of $N$ truncated Gaussian distributions centered at $\tilde \by_{1:N}$ with the bandwidth estimated by the KDE algorithm.
The Gaussians we sampled from were truncated at the lower and upper bounds of possible values for the given prediction target.
Finally, we discretized the sampled values to the target-specific bins.
These sampled points then make up the empirical predictive distribution from a KDE model.
We set the sample size to $N = 10^5$.  In theory, this model assigns non-zero probability to every possible outcome; however, in a few cases the empirical predictive distribution resulting from this Monte Carlo sampling approach assigned probability zero to some of the bins.

It is important to note that the predictions from this model do not change as new data are observed over the course of the season.

### Kernel Conditional Density Estimation (KCDE)
We used kernel conditional density estimation and copulas to estimate a joint predictive distribution for flu incidence in each future week of the season, and then calculated predictive distributions for each target from that joint distribution \cite{rayInPressKCDE}.
In our implementation, we first used KCDE to obtain separate predictive densities for flu incidence in each future week of the season.  Each of these predictive densities gives a conditional distribution for incidence at one future time point given recent observations of incidence and the current week of the season.  KCDE can be viewed as a distribution-based analogue of nearest-neighbors regression.  We then used a copula to model dependence among those individual predicitive densities, thereby obtaining a joint predicitive density, or a distribution of incidence trajectories in all future weeks.

To predict seasonal quantities (onset, peak timing, and peak incidence), we simulate $N = 10^5$ trajectories of disease incidence from this joint predictive distribution.
For each simulated incidence trajectory, we compute the onset week, peak week, and peak incidence.
We then aggregate these values to create predictive distributions for each target.
This procedure for obtaining predictive distributions for the targets of interest can be formally justified as an appropriate Monte Carlo integral of the joint predictive distribution for disease incidence in future weeks (see \cite{rayInPressKCDE} for details).

### Seasonal auto-regressive integrated moving average (SARIMA)
We fit seasonal ARIMA models \cite{Box2015} to wILI observations transformed to be on the natural log scale.  We manually performed first-order seasonal differencing and used the stepwise procedure from the `auto.arima` function in the `forecast` package \cite{Hyndman2008} for R to select the specification of the auto-regressive and moving average terms.

Similar to KCDE, forecasts were obtained by sampling $N = 10^5$ trajectories of wILI values over the rest of the season (using the `simulate.Arima` function from the `forecast` package), and predictive distributions of the targets were computed from these sampled trajectories as described above.

### Component model training

We used data from 14 seasons (1997/1998 through 2010/2011) to train the models.
Data from five seasons (2011/2012 through 2015/2016) were held out when fitting the models and used exclusively in the testing phase.
To avoid overfitting our models, we made predictions for the test phase only once \cite{Hastie2011}.

Estimation of the ensemble models (discussed in the next subsection) requires cross-validated measures of performance of each of the component models in order to accurately gauge their relative performance.
For each region, we estimated the parameters of each component model 15 times: 14 fits were obtained excluding one training season at a time, and another fit used all of the training data.
For each fit obtained leaving one season out, we generated a set of three predictive distributions (one for each of the prediction targets) at each week in the held-out season.
We were not able to generate predictions from the SARIMA and KCDE models for some seasons in the training phase because those models used lagged observations from previous seasons that were missing in our data set.
The component model fits based on all of the training data were used to generate predictions for the test phase.


## Ensemble models

All of the ensemble models we consider in this article work by averaging predictions from the component models to obtain the ensemble prediction.
Additionally, these methods are stacked model ensembles because they use leave-one-season-out predictions from the independently estimated component models as inputs to estimate the model weights \cite{Wolpert1992}.
We begin our discussion of ensemble methods with a general overview, introducing a common set of notation and giving a broad outline of the ensemble models we will use in this article.
We then describe our proposed weighted density ensemble model specifications in more detail.

### Overview of ensemble models

A single set of notation can be used to describe all of the ensemble frameworks implemented here.
Let $f_m(y_t|\bx_t^{(m)})$ denote the predictive density from component model $m$ for the value of the scalar random variable $Y_t$ conditional on observed variables $\bx_t^{(m)}$.  Observations of disease incidence are reported weekly in our data set, so $t$ indexes the week of the season.  The variable $Y_t$ could for example represent the peak incidence for a given season and region; in our application to predicting seasonal quantities, the same outcome $y_t$ will be realized for all weeks within a given season.
In the context of time series predictions, the covariate vector $\bx_t^{(m)}$ may include time-varying covariates such as the week at which the prediction is made or lagged incidence.  The superscript $^{(m)}$ reflects the fact that each component model may use a different set of covariates.

The combined predictive density $f(y_t|\bx_t)$ for a particular target can be written as
\begin{equation}
f(y_t|\bx_t) = \sum_{m = 1}^M \pi_m(\bx_t) f_m(y_t|\bx_t^{(m)}). \label{eqn:EnsembleModel}
\end{equation}
In Equation \eqref{eqn:EnsembleModel} the $\pi_m$ are the model weights, which are allowed to vary as a function of observed features in $\bx_t$.  We define $\bx_t$ to be a vector of all observed quantities that are used by any of the component models or in calculating the model weights.  In order to guarantee that $f(y_t|\bx_t)$ is a probability distribution we require that $\sum_{m = 1}^M \pi_m(\bx_t) = 1$ for all $\bx_t$.
Fig \ref{fig:stacking-concept} illustrates the concept of stacking the predictive densities for each component model.

In the following subsection, we propose a framework for estimating _feature-dependent weights_ for a stacked ensemble model.
By _feature-dependent_ we mean that the weights associated with different component models are driven by observed features or covariates.
Although we illustrate the method in the context of time-series predictions, the method could be used in any setting where we wish to combine distribution estimates from multiple models.
Features could include observed data from the system being predicted (such as recent wILI measurements or the time of year at which predictions are being made), observed data from outside the system (for example, recent weather observations), or features of the predictions themselves (e.g. summaries of the predictive distributions from the component models, such as a measure of spread in the distribution, or the time until a predicted peak).
Based on exploration of training phase data and _a priori_ knowledge of the disease system, we chose three features of the system to illustrate the proposed "feature-weighting" methodology:
week of season,
component model uncertainty (defined as the minimum number of predictive distribution bins required to cover 90% probability), and
wILI measurement at the time of prediction.
These features were chosen prior to and not changed after implementing test-phase predictions.

We used four distinct methodologies to define weights to use for the stacking models:

1. Equal Weights (\textbf{EW}): $\pi_m(\bx_t) = 1/M$. In this scenario, each model contributes the same weight for each target and for all values of $\bx_t$.

2. Constant model weights via degenerate EM (\textbf{CW}): $\pi_m(\bx_t) = c_m$, a constant where $\sum_{m=1}^M c_m = 1$ but the constants are not necessarily the same for each model. These weights are estimated using the degenerate estimation-maximization algorithm \cite{Lin2004}.  A separate set of weights is estimated for each region and prediction target.

3. Feature-weighted (\textbf{FW-wu}): $\pi_m(\bx_t)$ depends on features including week of the season and model uncertainty for the KCDE and SARIMA models.  A separate set of weighting functions is estimated for each region and prediction target.

4. Feature-weighted with regularization: $\pi_m(\bx_t)$ depends on features, but with regularization discouraging the weights from taking extreme values or from varying too quickly as a function of $\bx_t$.  A separate set of weighting functions is estimated for each region and prediction target.  We fit three variations on this ensemble model, using different sets of features:
    a. (\textbf{FW-reg-w}) week of the season;
    b. (\textbf{FW-reg-wu}) week of the season and model uncertainty for the KCDE and SARIMA models;
    c. (\textbf{FW-reg-wui}) week of the season, model uncertainty for the KCDE and SARIMA models, and incidence (wILI) in the most recent week.

All in all, this leads to 6 ensemble models, summarized in Table \ref{tbl:EnsembleModelSummaryTable}.  The first three of these models (\textbf{EW}, \textbf{CW}, and \textbf{FW-wu}) can be viewed as variations on \textbf{FW-reg-wu} if we vary the amount and type of regularization imposed on the \textbf{FW-reg-wu} model.  Thus, comparisons among these four models will enable us to explore the benefits of allowing the model weights to depend on covariates while imposing an appropriate amount of rigidity on the model weight functions $\pi_m(\bx_t)$.  We will discuss the regularization strategies used in \textbf{FW-reg-wu} further in the next subsection.  Meanwhile, comparisons among the \textbf{FW-reg-w}, \textbf{FW-reg-wu}, and \textbf{FW-reg-wui} models will allow us to explore the relative contributions to predictive performance that can be achieved by allowing the model weights to depend on different features.

\begin{table}[!ht]
\centering
\caption{\label{tbl:EnsembleModelSummaryTable}Summary of ensemble methods and what the model weights depend on.}
\begin{tabular}{rcccccc}
\toprule
         & \multicolumn{6}{c}{Component Model Weights Vary with...} \\
\cline{2-7}
  &   & Prediction & Week of & SARIMA & KCDE & Current \\
Model & Region & Target & Season & Uncertainty & Uncertainty & wILI \\
  \hline
EW         &   &   &   &   &   &   \\
CW        & X & X &   &   &   &   \\
FW         & X & X & X & X & X &   \\
FW-reg-w   & X & X & X &   &   &   \\
FW-reg-wu  & X & X & X & X & X &   \\
FW-reg-wui & X & X & X & X & X & X \\
\bottomrule
\end{tabular}
\end{table}

\newtext{As discussed above, leave-one-season-out prediction results from the three component models are inputs to the ensemble estimation routines.
During ensemble estimation, we dropped any training set time points for which cross-validated predictions from all three component models were not available.
After the training phase,} each of the six ensemble models, along with the three component models, are used to generate predictions in every season-week of each of the five testing seasons, assuming perfect reporting.
These predictions are then used to evaluate the prospective predictive performance of each of the ensemble methods.
In total, we evaluate 9 models in 11 regions over 5 years and 3 targets of interest.

## Feature-weighted stacking framework

In this section we introduce the particular specification of the parameter weight functions $\pi_m(\bx_t)$ that we use for the \textbf{FW-wu}, \textbf{FW-reg-w}, \textbf{FW-reg-wu}, and \textbf{FW-reg-wui} models and discuss estimation.

In order to ensure that the the $\pi_m$ are non-negative and sum to 1 for all values of $\bx_t$, we parameterize them in terms of the softmax transformation of real-valued latent functions $\rho_m$:
\begin{equation}
\pi_{m}(\bx_t) = \frac{\exp\{\rho_m(\bx_t)\}}{\sum_{m' = 1}^M \exp\{\rho_{m'}(\bx_t)\}}.  \label{eqn:PiSoftmaxRho}
\end{equation}
For a pair of models $l, m \in \{1, ..., M\}$, $\rho_l(\bx_t) > \rho_m(\bx_t)$ indicates that model $l$ has more weight than model $m$ for predictions at the given value of $\bx_t$.
The functions $\rho_m(\bx_t)$ could be parameterized and estimated using many different techniques, such as a linear specification in the features, splines, or so on.  We chose to estimate the functions $\rho_m(\bx)$ using gradient tree boosting.

Gradient tree boosting uses a forward stagewise additive modeling algorithm to iteratively and incrementally construct a series of regression trees that, when added together, create a function designed to minimize a given loss function.
In our application, the algorithm builds up the $\rho_m(\bx_t)$ that minimize the negative log-score of the stacked predictions $f(y_t|\bx_t)$ across all times $t$:
\begin{align}
L\{\brho(\bx_t)\} &= - \sum_{t} \log\{f(y_t|\bx_t)\} \nonumber \\
&= - \sum_{t} \log\left[\sum_{m = 1}^M \frac{\exp\{\rho_m(\bx_t)\}}{\sum_{m' = 1}^M \exp\{\rho_{m'}(\bx_t)\}}f_m(y_t|\bx_t^{(m)})\right], \label{eqn:logloss}
\end{align}
where $f_m(y_t|\bx_t^{(m)})$ is the cross-validated predictive density from the $m$th model evaluated at the realized outcome $y_t$.

Specifically, we define a single tree as
\begin{equation}
T(\bx_t; \btheta) = \sum_{j=1}^J \gamma_j I_{R_j\mbox{\newtext{(\bpsi)}}}(\bx_t),
\end{equation}
where the $R_j\mbox{\newtext{(\bpsi)}}$ are a set of disjoint regions that comprise a partition of the space $\mathcal{X}$ of feature values $\bx_t$, and $I$ is the indicator function taking the value $1$ if $\bx_t \in R_j\mbox{\newtext{(\bpsi)}}$ and $0$ otherwise. The parameters $\btheta = (\bpsi, \bgamma)$ for the tree are the split points $\bpsi$ partitioning $\mathcal{X}$ into the regions $R_j\mbox{\newtext{(\bpsi)}}$ and the regression constants $\bgamma$ associated with each region.
The function $\rho_m(\bx_t)$ is obtained as the sum of $B$ trees:
\begin{equation}
\rho_m(\bx_t; \Theta_m) = \sum_{b=1}^B T(\bx_t; \btheta_{m, b}).
\end{equation}

In each iteration $b$ of the boosting process, we estimate $M$ new regression trees, one for each component model.  These trees are estimated so as to minimize a local approximation to the loss function around the weight functions that were obtained after the previous boosting iteration.  Our approach builds on the `xgb.train` function in the `xgboost` package for `R` to perform this estimation \cite{xgboost}.  The functionality in that package assumes that the loss function is convex, and optimizes a quadratic approximation to the loss in each boosting iteration.  The loss function in Equation \eqref{eqn:logloss} is not guaranteed to be convex, so a direct application of this optimization method fails in our setting.  We have modified the implementation in the `xgboost` package to use a gradient descent step in cases where the loss is locally \newtext{nonconvex (concave or indeterminate)}.

Gradient tree boosting is appealing as a method for estimating the functions $\rho_m$ because it offers a great deal of flexibility in how the weights can vary as a function of the features $\bx_t$.  On the other hand, this flexibility can lead to overfitting the training data.  In order to limit the chances of overfitting, we have explored the use of three regularization parameters:

1. The number of boosting iterations $B$.  As $B$ increases, more extreme weights (close to 0 or 1) and more rapid changes in the weights as $\bx$ varies are possible.

2. An $L_1$ penalty on the number of tree leaves, $J$.  A large penalty encourages the regression trees to have fewer leaves, so that there is less flexibility for the model weights to vary as a function of $\bx_t$.

3. An $L_1$ penalty on the regression constants $\gamma_j$.  A large penalty encourages these constants to be small, so that the overall model weights change less in each boosting iteration.

We selected values for these regularization parameters using a grid search optimizing leave-one-season-out cross-validated model performance.

<!-- To prevent the stacking model from overfitting the training data, we estimate the model parameters by optimizing a penalized loss function where the penalty encourages the splines to be smooth.  The underlying unpenalized loss function is a measure of the quality of the final predictive distribution $f_t(y_t)$, obtained by cross-validation.  Because model performance will be evaluated using log scores, we will use negative cross-validated log scores as the loss function during parameter estimation: -->
<!-- The final predictions are obtained as a linear combination of the predictions from these component models.  The model weights depend on the week of the season in which the predictions are made.  We represent these weights as the softmax transformation of latent functions rho_ilt(season week) where i = 1, ..., 3 indexes the component model, l = 1, ..., 11 indexes the location (national or region 1 through 10), and t = 1, ..., 7 indexes the prediction target.  We estimate those latent functions rho_ilt via gradient tree boosting, optimizing leave-one-season-out crossvalidated log scores (using the definition of log scores specified for this competition). -->


<!-- Two feature-weighted (changing by season_week only, estimated separately by metric and region) -->
<!--   3a. season_week -->
<!--   3b. season_week*model_confidence -->
<!-- Three feature-weighted with regularization parameters chosen via cross-validation: -->
<!--   4a. season_week -->
<!--   4b. season_week*model_confidence -->
<!--   4c. season_week*model_confidence*lag1_ili -->

<!-- X = (week of season, model confidence, recent incidence) -->

<!-- 8 methods (1 equal-bin-weight + 3 component + 4 ensemble) / 3-7 metrics / 5 test seasons -->




## Software and code

We used R version 3.2.2 (2015-08-14) for all analyses \cite{Rcore2015}.
All data and code used for this analysis is freely available in an R package online at https://github.com/reichlab/adaptively-weighted-ensemble and may be installed in R directly.
Predictions generated in real-time with early development versions of this model during the 2016/2017 influenza season may be viewed at https://reichlab.io/flusight/.
To maximize reproducibility of our work, we have set seeds prior to running code that relies on stochastic simulations using the `rstream` package \cite{Leydold2015}.
Additionally, the manuscript itself was dynamically generated using RMarkdown.

# Results

To evaluate overall model performance, we computed log scores for all predictions made by each model across all regions and test phase seasons.  \newtext{Predictions made before the season peak (for predictions of peak incidence or peak timing) or before the season onset (for predictions of season onset timing) are the most relevant to decision makers using the predictions as inputs to set public policy.  We therefore focus our comparison of model performance on results for predictions made before the target event occurred within each of the test phase seasons.  Plots of the full predictive distributions at the national level from the \mbox{\textbf{FW-reg-w}} ensemble are presented in Supplemental Figs 1 through 3.}

\newtext{As discussed in the methods section, our test set contained predictions from each model for 3 targets over 5 seasons in 11 spatial units.  To ensure that seasons with later onsets or later peaks would not count more heavily than seasons with earlier onsets and peaks, and to simplify the analysis in the presence of serial autocorrelation in model performance over consecutive weeks, we summarized model performance within each season by the mean log score for all predictions made before the peak or onset week (as appropriate for the prediction target).  This led to 165 observations of model performance for each model, corresponding to the unique combinations of prediction target, season, and spatial unit.}

### Feature-weighted ensemble model weights reflect trends in component model log scores

Fig \ref{fig:example-weights} displays variation in leave-one-season-out log scores from the three component models over the course of the training phase seasons, along with the corresponding model weight estimates from the \textbf{CW} and \textbf{FW-reg-w} models.  Performance of the \textbf{SARIMA} and \textbf{KCDE} models is similar, with mean log scores from those models starting out near or slightly below the mean performance of \textbf{KDE}, but with performance improving as more data become available.  Near the beginning of some seasons, predictions from the \textbf{SARIMA} model are quite a bit worse than predictions from the other two component models.  Supplemental Fig 4 illustrates that these patterns are consistent across the other regions.  Supplemental Fig 5 shows that performance of the component models also varies with the model's uncertainty as measured by the number of bins required to cover 90\% in the predictive distribution, and Supplemental Fig 6 shows that performance varies with the observed wILI in the week when predictions are made.

The model weights assigned by the feature weighted ensemble models generally track these trends in relative model performance (Fig \ref{fig:example-weights}, \newtext{Supplemental Fig 7}).  For all three targets, at the national level the weight assigned to the \textbf{SARIMA} model increases and the weight assigned to \textbf{KDE} decreases as the season progresses.  However, the magnitude of shifts in model weights as the weighting features vary is different for the three prediction targets.

### Best models have similar aggregate performance

Aggregating across all combinations of \newtext{prediction target}, region, and season in the test phase, \newtext{the best component models and the best ensemble models} had similar performance (Fig \ref{fig:mean-pvals}).
\newtext{The \textbf{CW} ensemble had the highest average log scores across all three prediction targets, but a permutation test (described in the supplement) was unable to distinguish its performance from the \textbf{KCDE}, \textbf{SARIMA}, or \textbf{FW-reg-w} models.
However, these four methods all outperformed the \textbf{KDE} model in terms of mean log scores by a wide margin, as well as the \textbf{EW} and \textbf{FW-wu}, \textbf{FW-reg-wu}, and \textbf{FW-reg-wui} ensembles by narrower margins.  These general trends in model performance were similar for each of the three prediction targets individually; for example, Supplemental Fig 8 demonstrates that average performance of the \textbf{FW-reg-w} and \textbf{SARIMA} models is similar for all three prediction targets.}

\newtext{As noted above, our test set included only 5 seasons, and the effective sample size for model comparison is smaller than the 165 combinations of prediction target, region, and test phase season due to correlations in predictive performance across regions and seasons.  This may have contributed to our inability to detect statistically significant differences between the best models, and may limit the generalizability of these results; we will return to this point in the discussion.}

### Ensembles show stable performance for early-season predictions

\newtext{Although the aggregate performance of these models is quite similar, some differences between the methods begin to emerge when we examine performance in more detail.
Predictions that are used in setting public policy must be of consistent quality across all regions and seasons.
We observed that the component models showed more variability and lower worst-case performance than the ensemble methods.
The discussion in this subsection presents results of an exploratory analysis of the results, and all p-values are from post-hoc hypothesis tests.}

\newtext{To examine consistency of predictive performance, for each combination of prediction target, region, and test phase season we calculated the difference in mean log scores between each method and the method with median performance for that target, region, and season.
This measure of model performance relative to the median can be compared across prediction targets, regions, and seasons that may be predicted with varying levels of difficulty.
Figure \ref{fig:density_plot_diffs_from_median} displays these differences in performance relative to the median for just the \textbf{KCDE}, \textbf{SARIMA}, \textbf{CW}, and \textbf{FW-reg-w} methods. This comparison demonstrates that while these methods all had similar average performance, the \textbf{CW} and \textbf{FW-reg-w} ensemble methods had more consistent performance than the component models did, as is observed by the heavier distributional tails below zero on the horizontal axis.}

\newtext{We can quantify this observation by comparing the minimum performance relative to the median across all prediction targets, regions, and seasons for each method (Fig \ref{fig:median_diff_pvals}).
This comparison reveals that the \textbf{FW-reg-w} ensemble had better worst-case performance than all of the component models, and the \textbf{CW} ensemble had better worst-case performance than the \textbf{KDE} and \textbf{KCDE} component models.
These differences were both statistically and practically significant.
The differences between the ensemble and component models become more marked if we use the 10th percentile of performance differences relative to the median as a more stable measure of the lower tail of this distribution than the minimum (Supplemental Fig 9).
Additionally, the \textbf{FW-reg-w} model had a higher 10th percentile difference in performance from the median model than all other methods.
Across all three prediction targets and all test phase seasons, the \textbf{FW-reg-w} ensemble had the most consistent performance of all methods we considiered (Supplemental Fig 10).}

### Regularization improves feature-weighted ensemble models

The regularization of feature-weighted ensembles improved early-season prediction accuracy.
A comparison of the \textbf{FW-wu} and \textbf{FW-reg-wu} models shows improvements \newtext{in both mean performance and worst-case performance} when regularization was used to create smoother functions of model weights as a function of season week and model uncertainty \newtext{(Fig \mbox{\ref{fig:mean-pvals}}, Fig \mbox{\ref{fig:median_diff_pvals}})}.

```{r raw_data_plot, echo=FALSE, fig.height=4, fig.cap="\\label{fig:raw-data}Plot of influenza data.  The full data include observations aggregated to the national level and for 10 smaller regions.  Here we plot only the data at the national level and in two of the smaller regions; data for the other regions are qualitatively similar.  Missing data are indicated with vertical blue bars.  The vertical red dashed lines indicate the cutoff time between the training and testing phases; 5 seasons of data were held out for testing."}
flu_data$region[flu_data$region == "X"] <- "National"
flu_data$region <- factor(flu_data$region,
  levels = c("National", paste0("Region ", 1:10)))

regions_to_plot <- c("National", "Region 1", "Region 7")
#regions_to_plot <- c("National", paste0("Region ", 1:10))

train_cutoff_ind <- min(which(flu_data$season == "2011/2012"))
train_cutoff_time <- flu_data$time[train_cutoff_ind]
train_cutoffs <- data.frame(
  region = regions_to_plot,
  train_cutoff_time = as.numeric(as.Date(train_cutoff_time))
)

ggplot() +
  geom_line(aes(x = as.Date(time), y = weighted_ili),
    data = flu_data[flu_data$region %in% regions_to_plot & flu_data$season %in% paste0(1997:2015, "/", 1998:2016), ]) +
  geom_vline(aes(xintercept = as.numeric(as.Date(time))),
    colour = "blue",
    data = flu_data[is.na(flu_data$weighted_ili) & flu_data$region %in% regions_to_plot & flu_data$season %in% paste0(1997:2015, "/", 1998:2016), ]) +
  geom_vline(aes(xintercept = train_cutoff_time),
    colour = "red",
    linetype = 2,
    data = train_cutoffs) +
  facet_wrap(~ region, ncol = 1) +
  scale_x_date() +
  xlab("Time") +
  ylab("Weighted Proportion of Doctor's Office Visits\nwith Influenza-like Illness\n") +
#  ggtitle("Influenza Data by Region")
  theme_bw(base_size = 11)
```

<!--#### Fig: 9 panel grid (3 component models x 3 metrics) showing a solid line for each region that represents the average log score across all seasons \label{fig:log-scores}-->

```{r stacking-concept, echo=FALSE, fig.height=3, fig.width=9, fig.keep='last', warning=FALSE, message=FALSE, fig.cap="\\label{fig:stacking-concept}Conceptual diagram of how the stacking models operate on probabilistic predictive distributions. The distributions illustrated here have density bins of 1 wILI unit, which differs from those used in the manuscript for illustrative purposes only. Panel A shows the predictive distributions from three component models. Panel B shows scaled versions of the distributions from A, after being multiplied by model weights. In Panel C, the scaled distributions are literally stacked to create the final ensemble predictive distribution."}
awes_path <- find.package("awes")

kde_full <- readRDS(file.path(awes_path,
  "estimation/loso-predictions/kde-National-2005-2006-loso-predictions.rds"))
kcde_full <- readRDS(file.path(awes_path,
  "estimation/loso-predictions/kcde-National-2005-2006-loso-predictions.rds"))
sarima_full <- readRDS(file.path(awes_path,
  "estimation/loso-predictions/sarima-National-2005-2006-loso-predictions.rds"))

## get indices
tmp_week <- 20
idx_kde <- which(kde_full$analysis_time_season_week==tmp_week)
idx_kcde <- which(kcde_full$analysis_time_season_week==tmp_week)
idx_sarima <- which(sarima_full$analysis_time_season_week==tmp_week)

kde_dens <- kde_full %>%
    filter(analysis_time_season_week == tmp_week) %>%
    dplyr::select(starts_with("peak_inc_bin")) %>%
    as.numeric(.)

kcde_dens <- kcde_full %>%
    filter(analysis_time_season_week == tmp_week) %>%
    dplyr::select(starts_with("peak_inc_bin")) %>%
    as.numeric(.)

sarima_dens <- sarima_full %>%
    filter(analysis_time_season_week == tmp_week) %>%
    dplyr::select(starts_with("peak_inc_bin")) %>%
    as.numeric(.)

weights <- data_frame(
    mdl = factor(c("KCDE", "KDE", "SARIMA"), levels=c("KCDE", "KDE", "SARIMA")),
    weight = c(.5, .2, .3),
    x = 9,
    y=.4)

pred_dens <- data_frame(
    inc_bin = seq(0,13, .1),
    KDE = exp(kde_dens),
    KCDE = exp(kcde_dens),
    SARIMA = exp(sarima_dens)) %>%
    gather(
        key = mdl,
        value = probability,
        -inc_bin) %>%
    ## aggregate bins
    mutate(inc_bin = ceiling(inc_bin)) %>%
    group_by(mdl, inc_bin) %>%
    summarize(probability = sum(probability)) %>%
    left_join(weights) %>% ungroup() %>%
    mutate(mdl = factor(mdl, levels=c("KCDE", "KDE", "SARIMA")))

## make the base plot
color_palette <- c("#E69F00", "#56B4E9", "#009E73")
p_base <- ggplot(pred_dens) +
#    geom_col(aes(x=inc_bin, fill=mdl)) +
#    geom_bar(aes(x=inc_bin, fill=factor(mdl)), stat="identity", position = position_stack()) +
    scale_fill_manual(breaks = c("KCDE", "KDE", "SARIMA"), values = color_palette) +
    xlab("peak incidence value (binned wILI)") +
    coord_cartesian(xlim=c(0, 11), ylim=c(0, 0.5)) +
    theme_minimal() +
    theme(legend.position = "none", panel.grid.minor=element_blank())

## left hand tri-part panel
p1 <- p_base + aes(y=probability) + theme(strip.text.y = element_blank())+
    geom_bar(aes(x=inc_bin, fill=factor(mdl)), stat="identity", position = position_stack()) +
    facet_grid(mdl~.) + ggtitle("A: Original predictions") +
    geom_text(data=weights, aes(x=7.4, y=y, label=mdl), hjust=0, size=5)

## center tri-part panel
p2 <- p_base + aes(y=probability * weight) +
    geom_bar(aes(x=inc_bin, fill=factor(mdl)), stat="identity", position = position_stack()) +
    facet_grid(mdl~.) + ggtitle("B: Weighted predictions") +
    theme(strip.text.y = element_blank(), axis.title.y = element_blank()) +
    geom_text(data=weights, parse=TRUE,
        aes(x=x, y=y, label=paste(expression(pi[m]), "==", weight)))

## make complicated right hand panel

## top and bottom RHS
blankPlot <- ggplot() + geom_blank(aes(x=c(0,1),y=c(0,1))) +
    cowplot::theme_nothing()

title_plot <- blankPlot +
    geom_text(aes(x=0, y=.1,label="C: Stacked prediction"), hjust=0, size=4.5)

axis_plot <- blankPlot +
    geom_text(aes(x=.5, y=0.9,label="peak incidence value (binned wILI)"), size=4)

## middle left
p3 <- p_base + aes(y=probability * weight) +
    geom_bar(aes(x=inc_bin, fill=factor(mdl, levels = rev(levels(mdl)))), stat="identity", position = position_stack()) +
    theme(axis.title.y = element_blank(), axis.title.x=element_blank(),
      plot.margin = unit(c(2, 6, 0, 6), "pt"))

p4 <- grid.arrange(title_plot, p3, axis_plot)

grid.arrange(p1, p2, p4, ncol=3)

```


```{r log_scores_vs_analysis_time, echo=FALSE, cache=TRUE, fig.height=8, fig.cap="\\label{fig:ComponentModelLogScoresVsWeek}Mean, minimum, and maximum log scores achieved by each component model in each week of the season, summarizing across all seasons in both the training phase when all three component models produced predictions.", fig.show='hide'}
awes_path <- find.package("awes")
color_palette <- c("#E69F00", "#56B4E9", "#009E73")

log_scores <- bind_rows(
    assemble_predictions(
      preds_path = file.path(awes_path, "estimation/loso-predictions"),
      regions = c("National", paste0("Region", 1:10)),
      models = c("kde", "kcde", "sarima"),
      prediction_targets = c("onset", "peak_week", "peak_inc"),
      prediction_types = c("log_score")
    )
  ) %>%
  gather_("prediction_target", "log_score",
    paste0(c("onset", "peak_week", "peak_inc"), "_log_score")) %>%
  mutate(prediction_target = substr(prediction_target, 1, nchar(prediction_target) - 10))


summarized_log_scores <- log_scores %>%
  filter(analysis_time_season %in% paste0(1999:2015, "/", 2000:2016)) %>%
  group_by(model, region, prediction_target, analysis_time_season_week) %>%
  summarize(
    mean_log_score = mean(log_score),
    min_log_score = min(log_score),
    max_log_score = max(log_score)) %>%
  mutate(Model = toupper(model))
summarized_log_scores$prediction_target[summarized_log_scores$prediction_target == "onset"] <- "Onset Timing"
summarized_log_scores$prediction_target[summarized_log_scores$prediction_target == "peak_inc"] <- "Peak Incidence"
summarized_log_scores$prediction_target[summarized_log_scores$prediction_target == "peak_week"] <- "Peak Timing"
summarized_log_scores$prediction_target <- factor(summarized_log_scores$prediction_target,
  levels = c("Onset Timing", "Peak Timing", "Peak Incidence"))

regions_to_plot <- c("National", "Region1", "Region7")

ggplot() +
  geom_ribbon(
    aes(x = analysis_time_season_week,
      ymin = min_log_score,
      ymax = max_log_score,
      colour = Model,
      fill = Model,
      linetype = Model),
    alpha = 0.2,
    data = summarized_log_scores[summarized_log_scores$region %in% regions_to_plot, ]) +
  geom_line(
    aes(x = analysis_time_season_week,
      y = mean_log_score,
      colour = Model,
      linetype = Model),
    size = 1.5,
    data = summarized_log_scores[summarized_log_scores$region %in% regions_to_plot, ]) +
  scale_fill_manual(values = color_palette) +
  scale_colour_manual(values = color_palette) +
  facet_grid(region ~ prediction_target) +
  xlab("Week of Season at Analysis Time") +
  ylab("Log Score") +
  ggtitle("Log Scores vs. Week of Season at Analysis Time") +
  theme_bw()
```


```{r log_scores_and_weights_vs_analysis_time_setup, echo=FALSE, cache=TRUE}
get_legend_grob <- function(x) {
  data <- ggplot2:::ggplot_build(x)

  plot <- data$plot
  panel <- data$panel
  data <- data$data
  theme <- ggplot2:::plot_theme(plot)
  position <- theme$legend.position
  if (length(position) == 2) {
    position <- "manual"
  }

  legend_box <- if (position != "none") {
    ggplot2:::build_guides(plot$scales, plot$layers, plot$mapping,
      position, theme, plot$guides, plot$labels)
  } else {
    ggplot2:::zeroGrob()
  }
  if (ggplot2:::is.zero(legend_box)) {
    position <- "none"
  }
  else {
    legend_width <- gtable:::gtable_width(legend_box) + theme$legend.margin
    legend_height <- gtable:::gtable_height(legend_box) + theme$legend.margin
    just <- valid.just(theme$legend.justification)
    xjust <- just[1]
    yjust <- just[2]
    if (position == "manual") {
      xpos <- theme$legend.position[1]
      ypos <- theme$legend.position[2]
      legend_box <- editGrob(legend_box, vp = viewport(x = xpos,
        y = ypos, just = c(xjust, yjust), height = legend_height,
        width = legend_width))
    }
    else {
      legend_box <- editGrob(legend_box, vp = viewport(x = xjust,
        y = yjust, just = c(xjust, yjust)))
    }
  }
  return(legend_box)
}


awes_path <- find.package("awes")
color_palette <- c("#E69F00", "#56B4E9", "#009E73")

log_scores <- bind_rows(
    assemble_predictions(
      preds_path = file.path(awes_path, "estimation/loso-predictions"),
      regions = c("National", paste0("Region", 1:10)),
      models = c("kde", "kcde", "sarima"),
      prediction_targets = c("onset", "peak_week", "peak_inc"),
      prediction_types = c("log_score")
    )
  ) %>%
  gather_("prediction_target", "log_score",
    paste0(c("onset", "peak_week", "peak_inc"), "_log_score")) %>%
  mutate(prediction_target = substr(prediction_target, 1, nchar(prediction_target) - 10))


summarized_log_scores <- log_scores %>%
  filter(analysis_time_season %in% paste0(1999:2015, "/", 2000:2016) &
      prediction_target == "onset" &
      region == "National") %>%
  group_by(model, analysis_time_season_week) %>%
  summarize(
    mean_log_score = mean(log_score),
    min_log_score = min(log_score),
    max_log_score = max(log_score)) %>%
  mutate(Model = toupper(model),
    quantity = "Component Model Log Scores")

awes_path <- find.package("awes")

model_weights <- rbind.fill(
  readRDS(file.path(awes_path, "estimation/em-stacking/fits/em_weights.rds")) %>%
    filter(analysis_time_season_week == "all-combined" &
      region == "National" &
      prediction_target == "onset") %>%
    transmute(
      KDE = kde,
      KCDE = kcde,
      SARIMA = sarima,
      junk = TRUE
    ) %>%
    right_join(
      data.frame(
        junk = TRUE,
        ensemble_method = "CW",
        analysis_time_season_week = 10:40
      ),
      by = "junk"
    ) %>%
    gather_("model", "weight", c("KDE", "KCDE", "SARIMA")) %>%
    select_(.dots =
        c("ensemble_method", "analysis_time_season_week", "model", "weight")),
  readRDS(
    file = file.path(awes_path,
      "estimation/xgb-stacking/fits/model_weights_National_onset_analysis_time_season_week.rds")) %>%
    select_(.dots = c("analysis_time_season_week", paste0(c("kde", "kcde", "sarima"), "_log_score_params_combined"))) %>%
    `colnames<-`(c("analysis_time_season_week", "KDE", "KCDE", "SARIMA")) %>%
    gather_("model", "weight", c("KDE", "KCDE", "SARIMA")) %>%
    mutate(ensemble_method = "FW-reg-w")
) %>%
  mutate(quantity = "Component Model Weights")

p_onset_scores <- ggplot() +
  geom_ribbon(
    aes(x = analysis_time_season_week,
      ymin = min_log_score,
      ymax = max_log_score,
      colour = Model,
      fill = Model,
      linetype = Model),
    alpha = 0.2,
    data = summarized_log_scores[summarized_log_scores$analysis_time_season_week %in% 10:40, ]) +
  geom_line(
    aes(x = analysis_time_season_week,
      y = mean_log_score,
      colour = Model,
      linetype = Model),
    size = 1.5,
    data = summarized_log_scores[summarized_log_scores$analysis_time_season_week %in% 10:40, ]) +
#  facet_wrap( ~ quantity) +
  scale_fill_manual("Component\nModel", values = color_palette) +
  scale_colour_manual("Component\nModel", values = color_palette) +
  scale_linetype("Component\nModel") +
  ylim(c(-10.2,0)) +
#  xlab("Week of Season at Analysis Time") +
#  ylab("Log Score") +
#  ggtitle("A: Component Model Log Scores") +
  theme_bw(base_size = 11) +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    plot.margin = unit(c(6, 6, 0, 0), "pt"))

p_onset_weights <- ggplot() +
  geom_line(aes(x = analysis_time_season_week,
      y = weight,
      colour = model,
      linetype = model,
      size = ensemble_method
    ),
    data = model_weights[model_weights$analysis_time_season_week %in% 10:40, ]) +
#  facet_wrap( ~ quantity) +
  scale_linetype("Model") +
  scale_colour_manual("Model", values = color_palette) +
  scale_size_manual("Ensemble\nModel", breaks = c("CW", "FW-reg-w"), values = c(0.5, 1.5)) +
  ylim(c(0,1)) +
  xlab("Week of Season at Analysis Time") +
#  ylab("Model Weight") +
#  ggtitle("B: Component Model Weights") +
  theme_bw(base_size = 11) +
  theme(axis.title.y = element_blank(),
    legend.position = "none",
    plot.margin = unit(c(3, 6, 0, 5), "pt"))

component_legend <- get_legend_grob(p_onset_scores)
p_onset_scores <- p_onset_scores +
  theme(legend.position = "none")

ensemble_legend <- get_legend_grob(
  ggplot() +
  geom_line(aes(x = analysis_time_season_week,
      y = weight,
      size = ensemble_method
    ),
    data = model_weights) +
  scale_size_manual("Ensemble\nModel", breaks = c("CW", "FW-reg-w"), values = c(0.5, 1.5)) +
  theme_bw(base_size = 11)
)


summarized_log_scores <- log_scores %>%
  filter(analysis_time_season %in% paste0(1999:2015, "/", 2000:2016) &
      prediction_target == "peak_week" &
      region == "National") %>%
  group_by(model, analysis_time_season_week) %>%
  summarize(
    mean_log_score = mean(log_score),
    min_log_score = min(log_score),
    max_log_score = max(log_score)) %>%
  mutate(Model = toupper(model),
    quantity = "Component Model Log Scores")

model_weights <- rbind.fill(
  readRDS(file.path(awes_path, "estimation/em-stacking/fits/em_weights.rds")) %>%
    filter(analysis_time_season_week == "all-combined" &
      region == "National" &
      prediction_target == "peak_week") %>%
    transmute(
      KDE = kde,
      KCDE = kcde,
      SARIMA = sarima,
      junk = TRUE
    ) %>%
    right_join(
      data.frame(
        junk = TRUE,
        ensemble_method = "CW",
        analysis_time_season_week = 10:40
      ),
      by = "junk"
    ) %>%
    gather_("model", "weight", c("KDE", "KCDE", "SARIMA")) %>%
    select_(.dots =
        c("ensemble_method", "analysis_time_season_week", "model", "weight")),
  readRDS(
    file = file.path(awes_path,
      "estimation/xgb-stacking/fits/model_weights_National_peak_week_analysis_time_season_week.rds")) %>%
    select_(.dots = c("analysis_time_season_week", paste0(c("kde", "kcde", "sarima"), "_log_score_params_combined"))) %>%
    `colnames<-`(c("analysis_time_season_week", "KDE", "KCDE", "SARIMA")) %>%
    gather_("model", "weight", c("KDE", "KCDE", "SARIMA")) %>%
    mutate(ensemble_method = "FW-reg-w")
) %>%
  mutate(quantity = "Component Model Weights")

p_peak_week_scores <- ggplot() +
  geom_ribbon(
    aes(x = analysis_time_season_week,
      ymin = min_log_score,
      ymax = max_log_score,
      colour = Model,
      fill = Model,
      linetype = Model),
    alpha = 0.2,
    data = summarized_log_scores[summarized_log_scores$analysis_time_season_week %in% 10:40, ]) +
  geom_line(
    aes(x = analysis_time_season_week,
      y = mean_log_score,
      colour = Model,
      linetype = Model),
    size = 1.5,
    data = summarized_log_scores[summarized_log_scores$analysis_time_season_week %in% 10:40, ]) +
#  facet_wrap( ~ quantity) +
  scale_fill_manual("Component\nModel", values = color_palette) +
  scale_colour_manual("Component\nModel", values = color_palette) +
  scale_linetype("Component\nModel") +
  ylim(c(-10.2,0)) +
#  xlab("Week of Season at Analysis Time") +
#  ylab("Log Score") +
#  ggtitle("A: Component Model Log Scores") +
  theme_bw(base_size = 11) +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "none",
    plot.margin = unit(c(6, 6, 0, 0), "pt"))

p_peak_week_weights <- ggplot() +
  geom_line(aes(x = analysis_time_season_week,
      y = weight,
      colour = model,
      linetype = model,
      size = ensemble_method
    ),
    data = model_weights[model_weights$analysis_time_season_week %in% 10:40, ]) +
#  facet_wrap( ~ quantity) +
  scale_linetype("Model") +
  scale_colour_manual("Model", values = color_palette) +
  scale_size_manual("Ensemble\nModel", breaks = c("CW", "FW-reg-w"), values = c(0.5, 1.5)) +
  ylim(c(0,1)) +
  xlab("Week of Season at Analysis Time") +
#  ylab("Model Weight") +
#  ggtitle("B: Component Model Weights") +
  theme_bw(base_size = 11) +
  theme(axis.title.y = element_blank(),
    legend.position = "none",
    plot.margin = unit(c(3, 6, 0, 5), "pt"))




summarized_log_scores <- log_scores %>%
  filter(analysis_time_season %in% paste0(1999:2015, "/", 2000:2016) &
      prediction_target == "peak_inc" &
      region == "National") %>%
  group_by(model, analysis_time_season_week) %>%
  summarize(
    mean_log_score = mean(log_score),
    min_log_score = min(log_score),
    max_log_score = max(log_score)) %>%
  mutate(Model = toupper(model),
    quantity = "Component Model Log Scores")

model_weights <- rbind.fill(
  readRDS(file.path(awes_path, "estimation/em-stacking/fits/em_weights.rds")) %>%
    filter(analysis_time_season_week == "all-combined" &
      region == "National" &
      prediction_target == "peak_inc") %>%
    transmute(
      KDE = kde,
      KCDE = kcde,
      SARIMA = sarima,
      junk = TRUE
    ) %>%
    right_join(
      data.frame(
        junk = TRUE,
        ensemble_method = "CW",
        analysis_time_season_week = 10:40
      ),
      by = "junk"
    ) %>%
    gather_("model", "weight", c("KDE", "KCDE", "SARIMA")) %>%
    select_(.dots =
        c("ensemble_method", "analysis_time_season_week", "model", "weight")),
  readRDS(
    file = file.path(awes_path,
      "estimation/xgb-stacking/fits/model_weights_National_peak_inc_analysis_time_season_week.rds")) %>%
    select_(.dots = c("analysis_time_season_week", paste0(c("kde", "kcde", "sarima"), "_log_score_params_combined"))) %>%
    `colnames<-`(c("analysis_time_season_week", "KDE", "KCDE", "SARIMA")) %>%
    gather_("model", "weight", c("KDE", "KCDE", "SARIMA")) %>%
    mutate(ensemble_method = "FW-reg-w")
) %>%
  mutate(quantity = "Component Model Weights")

p_peak_inc_scores <- ggplot() +
  geom_ribbon(
    aes(x = analysis_time_season_week,
      ymin = min_log_score,
      ymax = max_log_score,
      colour = Model,
      fill = Model,
      linetype = Model),
    alpha = 0.2,
    data = summarized_log_scores[summarized_log_scores$analysis_time_season_week %in% 10:40, ]) +
  geom_line(
    aes(x = analysis_time_season_week,
      y = mean_log_score,
      colour = Model,
      linetype = Model),
    size = 1.5,
    data = summarized_log_scores[summarized_log_scores$analysis_time_season_week %in% 10:40, ]) +
#  facet_wrap( ~ quantity) +
  scale_fill_manual("Component\nModel", values = color_palette) +
  scale_colour_manual("Component\nModel", values = color_palette) +
  scale_linetype("Component\nModel") +
  ylim(c(-10.2,0)) +
#  xlab("Week of Season at Analysis Time") +
#  ylab("Log Score") +
#  ggtitle("A: Component Model Log Scores") +
  theme_bw(base_size = 11) +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "none",
    plot.margin = unit(c(6, 6, 0, 0), "pt"))

p_peak_inc_weights <- ggplot() +
  geom_line(aes(x = analysis_time_season_week,
      y = weight,
      colour = model,
      linetype = model,
      size = ensemble_method
    ),
    data = model_weights[model_weights$analysis_time_season_week %in% 10:40, ]) +
#  facet_wrap( ~ quantity) +
  scale_linetype("Model") +
  scale_colour_manual("Model", values = color_palette) +
  scale_size_manual("Ensemble\nModel", breaks = c("CW", "FW-reg-w"), values = c(0.5, 1.5)) +
  ylim(c(0,1)) +
  xlab("Week of Season at Analysis Time") +
#  ylab("Model Weight") +
#  ggtitle("B: Component Model Weights") +
  theme_bw(base_size = 11) +
  theme(axis.title.y = element_blank(),
    legend.position = "none",
    plot.margin = unit(c(3, 6, 0, 5), "pt"))
```

```{r log_scores_and_weights_vs_analysis_time, echo=FALSE, cache=TRUE, fig.height=8, fig.cap="\\label{fig:example-weights}Example of component model weights from the \\textbf{CW} and \\textbf{FW-reg-w} models for National predictions.  The upper plot within each panel shows mean, minimum, and maximum log scores achieved by each component model for predictions of the given prediction target at the national level in each week of the season, summarizing across all seasons in the training phase when all three component models produced predictions.  The lower plot within each panel shows model weights from the \\textbf{CW} and \\textbf{FW-reg-w} ensemble methods at each week in the season."}
grid.newpage()
blank_height <- 0
rel_height_lower <- 1.35
pushViewport(viewport(layout =
    grid.layout(nrow = 11, ncol = 3,
      heights = unit(
        c(1, 1, rel_height_lower, blank_height, 1, 1, rel_height_lower, blank_height, 1, 1, rel_height_lower),
        rep(c("lines", "lines", "null", "null"), 3)[2:12]),
      widths = unit(c(1, 4, 1), c("lines", "null", "null")))))
grid.text("A: Onset Timing",
  just = "left",
  gp = gpar(fontsize = 12),
  vp = viewport(layout.pos.row = 1, layout.pos.col = 1))
grid.text("B: Peak Timing",
  just = "left",
  gp = gpar(fontsize = 12),
  vp = viewport(layout.pos.row = 5, layout.pos.col = 1))
grid.text("C: Peak Incidence",
  just = "left",
  gp = gpar(fontsize = 12),
  vp = viewport(layout.pos.row = 9, layout.pos.col = 1))

ls_str <- "Log Score   "
mw_str <- "       Model Weight"
grid.text(ls_str,
  rot = 90,
  gp = gpar(fontsize = 10),
  vp = viewport(layout.pos.row = 2, layout.pos.col = 1))
grid.text(mw_str,
  rot = 90,
  gp = gpar(fontsize = 10),
  vp = viewport(layout.pos.row = 3, layout.pos.col = 1))
grid.text(ls_str,
  rot = 90,
  gp = gpar(fontsize = 10),
  vp = viewport(layout.pos.row = 6, layout.pos.col = 1))
grid.text(mw_str,
  rot = 90,
  gp = gpar(fontsize = 10),
  vp = viewport(layout.pos.row = 7, layout.pos.col = 1))
grid.text(ls_str,
  rot = 90,
  gp = gpar(fontsize = 10),
  vp = viewport(layout.pos.row = 10, layout.pos.col = 1))
grid.text(mw_str,
  rot = 90,
  gp = gpar(fontsize = 10),
  vp = viewport(layout.pos.row = 11, layout.pos.col = 1))

print(p_onset_scores, vp = viewport(layout.pos.row = 2, layout.pos.col = 2))
print(p_onset_weights, vp = viewport(layout.pos.row = 3, layout.pos.col = 2))
print(p_peak_week_scores, vp = viewport(layout.pos.row = 6, layout.pos.col = 2))
print(p_peak_week_weights, vp = viewport(layout.pos.row = 7, layout.pos.col = 2))
print(p_peak_inc_scores, vp = viewport(layout.pos.row = 10, layout.pos.col = 2))
print(p_peak_inc_weights, vp = viewport(layout.pos.row = 11, layout.pos.col = 2))

pushViewport(viewport(layout.pos.row = 6, layout.pos.col = 3))
grid.draw(component_legend)
upViewport()
pushViewport(viewport(layout.pos.row = 7, layout.pos.col = 3))
grid.draw(ensemble_legend)
upViewport()
```

# Discussion

In this work we have examined the potential for ensemble methods to improve infectious disease predictions.
We explored a nested series of ensemble methods, focusing on methods that computed weighted averages of predictive distributions for seasonal targets of public health interest, such as the peak intensity of the outbreak and the timing of both season onset and peak.
The methods we examined ranged from using equal model weights to more complex schemes with weights that varied as functions of multiple covariates.
The \newtext{best of these} ensemble methods achieved overall performance that was about as good as the \newtext{best of the} individual component models, with increased stability in model performance across different \newtext{regions and} seasons.

Increased stability in predictive accuracy can provide decision makers with more confidence when using predictions as inputs to set policy.
For example, if a single model does well in most seasons but occasionally fails badly, planning decisions may be negatively impacted in those failing years.
This may be particularly important in a public health setting where the events that are most important to get right are those relatively rare cases when incidence is much larger than usual or the season timing is earlier or later than usual.
This reduction in variability of model performance achieved by ensemble methods is therefore important for ensuring that our predictions are reliable under a variety of conditions.

\newtext{Among the different ensemble specifications we considered, the \textbf{CW} and \textbf{FW-reg-w} models had slightly better average performance during the test phase than the three other ensemble methods that included some form of regularization on the model weighting functions, and much better performance than an ensemble with unregularized weighting function.
The \textbf{FW-reg-wui} and \textbf{FW-reg-wu} ensembles did not outperform the simpler \textbf{FW-reg-w} ensemble}, indicating that including model uncertainty and recent observations of disease incidence did not add much more information about relative model performance than was available from the week of the season in which predictions were generated.
\newtext{Analysis of worst-case performance suggests that the \textbf{FW-reg-w} ensemble had more stable performance across different regions and seasons than the other ensemble specifications.  However, whether or not this difference was statistically significant depended on the measure of worst-case performance used.
Overall,} the \textbf{FW-reg-w} method had good average and worst-case performance across all test phase seasons and prediction targets\newtext{; the \textbf{CW} ensemble had similar average performance, but its worst-case performance was not as good as that of the \textbf{FW-reg-w} method}.

\newtext{All hypothesis tests we conducted related to worst-case performance were post-hoc tests conducted after an exploratory analysis of relative model performance, and these results should be confirmed in future studies.  Additionally, the permutation test we used accounts for serial autocorrelation in model performance within a region-season, but does not account for correlation across region or seasons; thus the p-values discussed throughout this work should be regarded as only approximate indicators of statistical significance.}

The feature-weighted ensemble models presented in this article use a novel scheme to estimate feature-dependent model weights that sum to 1 and are therefore suitable for use in combining predictive distributions.
This general method could be applied to combine distribution estimates in any context, and is not limited to time-series or infectious disease applications.
Furthermore, comparing an implementation of the feature-weighting that smoothed the model weights to one that did not showed consistent improvements in model performance.
This result suggests that future work on feature-weighted ensemble implementations should consider regularized estimation.

<!--In future applications to infectious disease, it may be possible to use a framework like feature-weighed stacking to identify epidemiological features that are responsible for shifting the transmission dynamics from one regime to another.
For example, there may be circumstances where measurable characteristics of the dynamical system, such as patterns of weather or population movement, could provide valuable information about future transmission dynamics.
Therefore, examining the weights estimated for specific subsets of component models that contain data on these characteristics could provide insights into the drivers of the epidemiological dynamics of the system. -->

Infectious disease predictions are only useful to public health officials if they are communicated effectively in real time.  Predictions from an early version of the \textbf{FW-reg-w} model were updated weekly during the 2016/2017 influenza season and disseminated through an interactive website at https://reichlab.io/flusight/.
\newtext{While we have successfully deployed the methods discussed here in a real-time setting, in this article we have ignored the important issue of reporting delays that occur with real-time data.
All models were trained using the finalized value of the incidence measure, and these finalized values were used to make the cross-validated predictions that were inputs to the ensemble estimation as well as the predictions for the test set evaluation.
Some component models may be more or less sensitive to reporting delays than other models, and this could lead to inappropriate estimates for the ensemble weighting functions if finalized data were used for the cross-validated predictions but the methods were then used in real time.
Ideally, the cross-validated model log scores used to estimate the ensemble weighting functions should be obtained using the same sort of "non-finalized" data that the models will encounter when making real-time predictions.}

<!--[[TODO: Discuss how varying some of these regularization parameters can give the simpler EW and dEM models??  Or ignore?  Or defer to supplement?]]-->

A central challenge of working with infectious disease data sets is the limited number of years of data available for model estimation and evaluation.  We have used approximately one fourth of our data set for model evaluation, which left us with only 14 seasons of training data and 5 seasons of testing data.  Additionally, we had fewer than 14 seasons of leave-one-season-out predictions to use in estimating the model weighting functions for the \textbf{FW-wu} ensemble methods because the \textbf{SARIMA} model required unobserved seasonally lagged incidence to make predictions for the first few seasons in the training phase.  This small sample size may have negatively impacted our ability to estimate the weighting functions.  \newtext{Altogether the test phase included 55 combinations of region and season, with a total of 2469 predictions from each method made across all three prediction targets before the test phase season onset or peak occurred.  Nevertheless,} because of the high degree of correlation in model log scores for the same prediction target in different weeks and regions within the same season \newtext{we have a smaller effective sample size for detecting differences in average model performance in the test phase.
The findings in this work should be confirmed with additional data sets.  Another possible avenue would be to obtain pseudo out-of-sample results by performing cross validation within the training phase.}

Another limitation of this work is the small selection of component models used.  Theoretical results and applications have demonstrated that ensemble methods are most effective when using a diverse set of component models \cite{polikar2006ensemble}.  In our study, the \textbf{KCDE} and \textbf{SARIMA} component models are similar in that they both use seasonal terms and observations of recent incidence \newtext{to inform their predictions} (though we note that these two models tended to perform well in different seasons, as illustrated in Supplemental Fig 10).  Increased component model diversity could yield improved ensemble performance; this could be achieved either through inclusion of different model structures (\newtext{for example,} agent-based or mechanistic models \newtext{such as those explored in \mbox{\cite{Shaman2012, shaman2013realTimeInfluenza, shaman2015improvedInfluenzaEnsembleConsecutivePredictions, yang2014comparisonFilteringInfluenza, yang2015forecastingInfluenzaHongKong, yang2016forecasting}}}) or different covariates (such as \newtext{information about the circulating strains of a disease}, spatial effects, weather, or \newtext{social media data, as used by \mbox{\cite{chakraborty2014forecastingILIEnsemble, hickmann2015forecastingInfluenzaWikipedia, paul2014twitterInfluenzaForecasting,   santillana2015combiningSearchTwitterInfluenza, Shaman2012, shaman2013realTimeInfluenza, yang2014comparisonFilteringInfluenza, yang2016forecasting}}).  Thus, the current work should not be viewed as a competitor to the models developed in previous work, but rather as a method for integrating and unifying the diverse array of methods that have been developed in the literature.  The methods presented here are suitable for combining predictions from any collection of component models that each output a full predictive distribution, regardless of model structure.}

Our exploration of feature-weighted ensembles is also limited by the relatively restricted feature sets we used for the weighting functions.  We selected a few features based on exploratory analysis of the training phase results, and set all ensemble model formulations before obtaining any predictions for the test phase.  It is possible that other weighting features not considered in this work may be more informative than those we have used.  Some ideas for weighting covariates to use in future work include the largest incidence so far this season; the onset threshold; alternative summaries of the predictive distributions from the component models such as the probability at the mode or the modal value; the predominant flu strain; or the distribution of incidence in age groups.

\newtext{The performance of the ensemble methods might be improved by subsetting the training data for the ensembles to the most important observations.  The discrepancy in this work between the times used to train the ensembles (all leave-one-season-out predictions) and the times used for model comparison (only predictions made before the season onset or peak) may have led to an artificial decline in performance for the ensembles; this may be especially so for the relatively inflexible \textbf{CW} method.}

This work provides a rigorous and comprehensive evaluation of ensemble methods for averaging probabilistic  predictions for features of infectious disease outbreaks.
A range of models, both single component models and ensemble models that combined component model predictions, demonstrated the ability to make more accurate predictions than a seasonal average baseline model.
Additionally, systematic comparisons of simple and complex prediction models highlight a crucial added value of ensemble modeling, namely increased stability and consistency of model performance \newtext{relative to the component models}.
Continued investigation, application, and innovation is necessary to strengthen our understanding of how to best leverage combinations of models to assist decision makers in fields, such as public health and infectious disease surveillance, that require data-driven rapid response.

# Acknowledgments

This work was supported by Award Number R35GM119582 from the National Institute Of General Medical Sciences and Defense Advanced Projects Research Agency Young Faculty Award Number Dl6AP00144. The content is solely the responsibility of the authors and does not necessarily represent the official views of the National Institute Of General Medical Sciences, the National Institutes of Health, or the Defense Advanced Projects Research Agency.  The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.

```{r test-phase-plot-summary, eval=FALSE, echo = FALSE}
## plots created for MIDAS meeting evaluation
target_to_plot <- "Peak Incidence"
preds_to_plot <- filter(preds,
                        prediction_target==target_to_plot,
                        region %in% c("National", "Region1", "Region7"))

## three reds, blues and blacks
# cols <- c(RColorBrewer::brewer.pal(4, "Reds")[2:4],
#           RColorBrewer::brewer.pal(9, "Blues")[2:9])
cols <- c("KDE" = RColorBrewer::brewer.pal(4, "Reds")[2],
          "KCDE" = RColorBrewer::brewer.pal(4, "Reds")[3],
          "SARIMA" = RColorBrewer::brewer.pal(4, "Reds")[4],
          "EW" = RColorBrewer::brewer.pal(9, "Blues")[3],
          "CW" = RColorBrewer::brewer.pal(9, "Blues")[3],
          "FW-wu" = RColorBrewer::brewer.pal(9, "Blues")[3],
          "FW-reg-w" = RColorBrewer::brewer.pal(9, "Blues")[9],
          "FW-reg-wu" = RColorBrewer::brewer.pal(9, "Blues")[3],
          "FW-reg-wui" = RColorBrewer::brewer.pal(9, "Blues")[3])
ggplot(preds_to_plot, aes(x=analysis_time_season_week, y=log_score, color=model)) +
    geom_line(alpha=.8) + scale_color_manual(values=cols) +
    facet_grid(region~analysis_time_season) +
    xlab("season week") + ylab("log score") +
    ggtitle(target_to_plot)
```


```{r perm_test_means, echo=FALSE, cache = TRUE}
awes_path <- find.package("awes")

all_models <- c("KDE", "KCDE", "SARIMA", "EW", "CW", "FW-wu", "FW-reg-w", "FW-reg-wu", "FW-reg-wui")

region_season_obs_quantities <- flu_data %>%
  select_(.dots = c("region", "season")) %>%
  distinct() %>%
  filter(season %in% paste0(2011:2015, "/", 2012:2016)) %>%
  mutate(
    observed_onset_week = NA,
    observed_peak_week = NA
  )

for(rs_row in seq_len(nrow(region_season_obs_quantities))) {
  temp <- get_observed_seasonal_quantities(
    data = flu_data[flu_data$region == region_season_obs_quantities$region[rs_row], , drop = FALSE],
    season = region_season_obs_quantities$season[rs_row],
    first_CDC_season_week = 10,
    last_CDC_season_week = 42,
    onset_baseline =
      get_onset_baseline(region = region_season_obs_quantities$region[rs_row],
        season = region_season_obs_quantities$season[rs_row]),
    incidence_var = "weighted_ili",
    incidence_bins = data.frame(
      lower = c(0, seq(from = 0.05, to = 12.95, by = 0.1)),
      upper = c(seq(from = 0.05, to = 12.95, by = 0.1), Inf)),
    incidence_bin_names = as.character(seq(from = 0, to = 13, by = 0.1))
  )

  region_season_obs_quantities$observed_onset_week[rs_row] <-
    temp$observed_onset_week
  region_season_obs_quantities$observed_peak_week[rs_row] <-
    temp$observed_peak_week[1]
}

region_season_obs_quantities$observed_onset_week[
  region_season_obs_quantities$observed_onset_week == "none"] <- 42
region_season_obs_quantities <- region_season_obs_quantities %>%
  transmute(
    region = ifelse(region == "X", "National", gsub(" ", "", region)),
    analysis_time_season = season,
    observed_onset_week = as.numeric(observed_onset_week),
    observed_peak_week = observed_peak_week
  )

all_models <- c("kde", "kcde", "sarima", "equal_weights", "em_stacking", "xgb_stacking_unregularized", "xgb_stacking_reg_w", "xgb_stacking_reg_wu", "xgb_stacking_reg_wui")
all_targets <- c("onset", "peak_week", "peak_inc")
preds <- assemble_predictions(
  preds_path = file.path(awes_path, "evaluation/test-predictions"),
  models = all_models,
  prediction_targets = all_targets,
  prediction_types = "log_score"
) %>%
  filter(analysis_time_season_week %in% 10:40) %>%
  gather_("prediction_target", "log_score",
    c("onset_log_score", "peak_week_log_score", "peak_inc_log_score")) %>%
  mutate(
    prediction_target = substr(prediction_target, 1, nchar(prediction_target) - 10),
    score = exp(log_score)
  )

preds$log_score[is.infinite(preds$log_score)] <- -15
preds <- preds %>%
  left_join(region_season_obs_quantities, by = c("region", "analysis_time_season")) %>%
  mutate(
    before_onset = (analysis_time_season_week < observed_onset_week),
    before_peak = (analysis_time_season_week < observed_peak_week))

preds$before_target_date <- ifelse(
  preds$prediction_target == "onset",
  c("on or after\ntarget date", "before\ntarget date")[preds$before_onset + 1],
  c("on or after\ntarget date", "before\ntarget date")[preds$before_peak + 1]
)

preds$model[preds$model == "kde"] <- "KDE"
preds$model[preds$model == "kcde"] <- "KCDE"
preds$model[preds$model == "sarima"] <- "SARIMA"
preds$model[preds$model == "equal_weights"] <- "EW"
preds$model[preds$model == "em_stacking"] <- "CW"
preds$model[preds$model == "xgb_stacking_unregularized"] <- "FW-wu"
preds$model[preds$model == "xgb_stacking_reg_w"] <- "FW-reg-w"
preds$model[preds$model == "xgb_stacking_reg_wu"] <- "FW-reg-wu"
preds$model[preds$model == "xgb_stacking_reg_wui"] <- "FW-reg-wui"
preds$model <- factor(preds$model,
  levels = c("KDE", "KCDE", "SARIMA",
    "EW", "CW", "FW-wu",
    "FW-reg-w", "FW-reg-wu", "FW-reg-wui"))

preds$prediction_target[preds$prediction_target == "onset"] <- "Onset Timing"
preds$prediction_target[preds$prediction_target == "peak_inc"] <- "Peak Incidence"
preds$prediction_target[preds$prediction_target == "peak_week"] <- "Peak Timing"
preds$prediction_target <- factor(preds$prediction_target,
  levels = c("Onset Timing", "Peak Timing", "Peak Incidence"))

preds <- preds %>%
  mutate(
    region = factor(region),
    analysis_time_season = factor(analysis_time_season)
  )


preds_wide <- preds %>%
#  dplyr::filter(before_target_date == "before\ntarget date") %>%
  dplyr::select(-score) %>%
  tidyr::spread(model, log_score)

registerDoMC(cores = 4)

all_models <- c("KDE", "KCDE", "SARIMA", "EW", "CW", "FW-wu", "FW-reg-w", "FW-reg-wu", "FW-reg-wui")
m_combos <- expand.grid(
  m1_ind = seq_along(all_models),
  m2_ind = seq_along(all_models)) %>%
  filter(m1_ind < m2_ind)
m_combos$m1 <- all_models[m_combos$m1_ind]
m_combos$m2 <- all_models[m_combos$m2_ind]


res <- mean(log_score ~ model + prediction_target + analysis_time_season + region,
  data = preds[preds$before_target_date == "before\ntarget date", ])
temp <- strsplit(names(res), ".", fixed = TRUE) %>%
  unlist() %>%
  matrix(ncol = 4, byrow = TRUE)
res <- cbind(temp, res) %>%
  as.data.frame(stringsAsFactors = FALSE) %>%
  `colnames<-`(c("model", "prediction_target", "season", "region", "mean_log_score")) %>%
  `rownames<-`(NULL) %>%
  group_by_(.dots = c("prediction_target", "season", "region")) %>%
  mutate(mean_log_score = as.numeric(mean_log_score),
    rank = rank(-1 * round(as.numeric(mean_log_score), 3)))

res$prediction_target <- factor(res$prediction_target,
  levels = c("Onset Timing", "Peak Timing", "Peak Incidence"))
res$model <- factor(res$model,
  levels = c("KDE", "KCDE", "SARIMA",
    "EW", "CW", "FW-wu",
    "FW-reg-w", "FW-reg-wu", "FW-reg-wui"))

res$region_season <- paste0(res$region, " - ", res$season)

median_per_target_season_region <- res %>%
  group_by(prediction_target, season, region) %>%
  summarize(median_mean_log_score = median(mean_log_score))

res2 <- res %>%
  left_join(median_per_target_season_region, by = c("prediction_target", "season", "region")) %>%
  mutate(diff_from_median = mean_log_score - median_mean_log_score)

all_models <- c("KDE", "KCDE", "SARIMA", "EW", "CW", "FW-wu", "FW-reg-w", "FW-reg-wu", "FW-reg-wui")
#all_models <- c("kde", "kcde", "sarima", "equal_weights", "em_stacking", "xgb_stacking_unregularized", "xgb_stacking_reg_w", "xgb_stacking_reg_wu", "xgb_stacking_reg_wui")

m_combos <- expand.grid(
  m1_ind = seq_along(all_models),
  m2_ind = seq_along(all_models)) %>%
  filter(m1_ind < m2_ind)
m_combos$m1 <- all_models[m_combos$m1_ind]
m_combos$m2 <- all_models[m_combos$m2_ind]

perm_test_res <- foreach(i = seq_len(nrow(m_combos))) %dopar% {
  model_pair <- m_combos[i, c("m1", "m2")]

  perm_res <- rbind.fill(lapply(seq_len(100), function(j) {
    perm_model_scores <- readRDS(
#          file = paste0("../../../inst/manuscript/score-permutations/perm_model_scores_season_mean_",
            file = paste0("~/Documents/research/epi/ensembles/adaptively-weighted-ensemble/inst/manuscript/score-permutations/perm_model_scores_season_mean_",
            model_pair[1],
            "_", model_pair[2],
            "_", j,
            ".rds"))

    lapply(perm_model_scores,
      function(comp) {
        temp <- apply(comp, 2, mean)
        return(data.frame(model_1_score = unname(temp[1]),
          model_2_score = unname(temp[2]),
          model_pair = paste(names(temp), collapse = "_"),
          statistic = "mean_mean_log_score"))
#        comp %>%
#          gather("model", "mean_log_score", colnames(comp)) %>%
#          group_by(model) %>%
#          summarize(mean_mean_log_score = mean(mean_log_score)) %>%
#          gather("statistic", "value", colnames(.)[2]) %>%
#          mutate(model_pair = paste(colnames(comp), collapse = "_"))
      }) %>%
      rbind.fill()
  }))
}

realized_res <- res2 %>%
  group_by(model) %>%
  summarize(mean_mean_log_score = mean(mean_log_score)) %>%
  gather("statistic", "value", mean_mean_log_score) %>%
  mutate(model = as.character(model))

perm_test_c <- rbind.fill(perm_test_res)

perm_test_summaries <- perm_test_c %>%
  dplyr::mutate(
    model_pair = as.character(model_pair),
    statistic = as.character(statistic),
    perm_abs_diff = abs(model_1_score - model_2_score)) %>%
  dplyr::mutate(model_1 = sapply(strsplit(model_pair, "_"), function(comp) {comp[[1]]}),
    model_2 = sapply(strsplit(model_pair, "_"), function(comp) {comp[[2]]})
    ) %>%
  dplyr::left_join(realized_res, by = c("model_1" = "model", "statistic")) %>%
  dplyr::mutate(model_1_score_true = value) %>%
  dplyr::select(-value) %>%
  dplyr::left_join(realized_res, by = c("model_2" = "model", "statistic")) %>%
  dplyr::mutate(model_2_score_true = value) %>%
  dplyr::select(-value) %>%
  dplyr::mutate(realized_diff = model_1_score_true - model_2_score_true,
    realized_abs_diff = abs(model_1_score_true - model_2_score_true)) %>%
  dplyr::group_by(statistic, model_pair, model_1, model_2, realized_diff) %>%
  dplyr::summarize(abs_diff_pval = mean(perm_abs_diff >= realized_abs_diff))

realized_res <- mutate(realized_res, model = factor(model, levels = all_models))
```

```{r perm_test_means_plot, echo=FALSE, fig.height=8, fig.cap="\\label{fig:mean-pvals}For each combination of 3 prediction targets, 11 regions, and 5 test phase seasons, we calculated the mean log score for all predictions made by each method in weeks before the event being predicted occurred.  Panel A presents the overall mean of these values for each method; higher mean log scores indicate better performance.  Panel B displays the difference in mean log scores for each pair of models.  Positive values indicate that the model on the vertical axis outperformed the model on the horizontal axis on average.  A permutation test was used to obtain approximate p-values for these differences (see supplement for details).  For reference, a Bonferroni correction at a familywise significance level of 0.05 for all pairwise comparisons leads to a significance cutoff of approximately 0.0014."}
stat_ind <- 1
stat_val <- unique(perm_test_summaries$statistic)[stat_ind]

realized_res <- res2 %>%
  group_by(model) %>%
  summarize(mean_mean_log_score = mean(mean_log_score)) %>%
  gather("statistic", "value", mean_mean_log_score)

p_res <- ggplot(
    data = realized_res %>%
      filter(statistic == "mean_mean_log_score") %>%
      mutate(y = 0)) +
  geom_tile(aes(x = model, y = y, fill = value)) +
  geom_text(aes(x = model, y = y, label=format(round(value, 3), nsmall = 3)),
    size = 3) +
  scale_fill_gradient2("",
    low = "#b2182b",
    mid = "#f7f7f7",
    high = "#2166ac",
    midpoint = mean(range(realized_res$value[realized_res$statistic == "mean_mean_log_score"]))) +
#    midpoint = 0) +
  xlab("Model") +
  ylab("") +
  ggtitle("A: Mean Log Score") +
  theme_bw() +
  theme(axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),
    plot.margin = unit(c(5.5, 5.5, 5.5, 55.5), "pt"))


perm_test_for_plot <- perm_test_summaries %>% filter(statistic == stat_val) %>%
  ungroup() %>%
  mutate(
    model_1 = factor(model_1, levels = all_models),
    model_2 = factor(model_2, levels = all_models)
    )
perm_test_for_plot2 <- perm_test_for_plot
perm_test_for_plot2$model_1 <- perm_test_for_plot$model_2
perm_test_for_plot2$model_2 <- perm_test_for_plot$model_1
perm_test_for_plot2$realized_diff <- -1 * perm_test_for_plot$realized_diff
perm_test_for_plot_c <- rbind(perm_test_for_plot, perm_test_for_plot2)

p_pvals <- ggplot(data = perm_test_for_plot_c) +
  geom_tile(aes(x = model_2, y = model_1, fill = realized_diff)) +
  geom_text(aes(x = model_2, y = model_1, label=paste0(
    format(round(realized_diff, 3), nsmall = 3),
    "\n(",
    format(round(abs_diff_pval, 3), nsmall = 3),
    ")")),
    size = 3) +
#  geom_text(aes(x = m1, y = m2, label=paste0(pval_diff)),
#    size = 3) +
  scale_fill_gradient2("",
#    breaks = 1:9,
#    labels = as.character(1:9),
    low = "#b2182b",
    mid = "#f7f7f7",
    high = "#2166ac",
#    low = "#2166ac",
#    mid = "#f7f7f7",
#    high = "#b2182b",
    midpoint = 0) +
  xlab("Model") +
  ylab("Model") +
  ggtitle("B: Pairwise differences in Mean Log Scores") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),
    panel.grid.minor=element_blank(),
    panel.grid.major=element_blank())


grid.newpage()
blank_height <- 0
rel_height_lower <- 1.35
pushViewport(viewport(layout =
    grid.layout(nrow = 2, ncol = 1,
      heights = unit(
        c(1, 3),
        c("null", "null")),
      widths = unit(c(1), c("null")))))
print(p_res, vp = viewport(layout.pos.row = 1, layout.pos.col = 1))
print(p_pvals, vp = viewport(layout.pos.row = 2, layout.pos.col = 1))
```



```{r perm_test_diff_from_medians, echo=FALSE, cache = TRUE}
awes_path <- find.package("awes")

all_models <- c("KDE", "KCDE", "SARIMA", "EW", "CW", "FW-wu", "FW-reg-w", "FW-reg-wu", "FW-reg-wui")

region_season_obs_quantities <- flu_data %>%
  select_(.dots = c("region", "season")) %>%
  distinct() %>%
  filter(season %in% paste0(2011:2015, "/", 2012:2016)) %>%
  mutate(
    observed_onset_week = NA,
    observed_peak_week = NA
  )

for(rs_row in seq_len(nrow(region_season_obs_quantities))) {
  temp <- get_observed_seasonal_quantities(
    data = flu_data[flu_data$region == region_season_obs_quantities$region[rs_row], , drop = FALSE],
    season = region_season_obs_quantities$season[rs_row],
    first_CDC_season_week = 10,
    last_CDC_season_week = 42,
    onset_baseline =
      get_onset_baseline(region = region_season_obs_quantities$region[rs_row],
        season = region_season_obs_quantities$season[rs_row]),
    incidence_var = "weighted_ili",
    incidence_bins = data.frame(
      lower = c(0, seq(from = 0.05, to = 12.95, by = 0.1)),
      upper = c(seq(from = 0.05, to = 12.95, by = 0.1), Inf)),
    incidence_bin_names = as.character(seq(from = 0, to = 13, by = 0.1))
  )

  region_season_obs_quantities$observed_onset_week[rs_row] <-
    temp$observed_onset_week
  region_season_obs_quantities$observed_peak_week[rs_row] <-
    temp$observed_peak_week[1]
}

region_season_obs_quantities$observed_onset_week[
  region_season_obs_quantities$observed_onset_week == "none"] <- 42
region_season_obs_quantities <- region_season_obs_quantities %>%
  transmute(
    region = ifelse(region == "X", "National", gsub(" ", "", region)),
    analysis_time_season = season,
    observed_onset_week = as.numeric(observed_onset_week),
    observed_peak_week = observed_peak_week
  )

all_models <- c("kde", "kcde", "sarima", "equal_weights", "em_stacking", "xgb_stacking_unregularized", "xgb_stacking_reg_w", "xgb_stacking_reg_wu", "xgb_stacking_reg_wui")
all_targets <- c("onset", "peak_week", "peak_inc")
preds <- assemble_predictions(
  preds_path = file.path(awes_path, "evaluation/test-predictions"),
  models = all_models,
  prediction_targets = all_targets,
  prediction_types = "log_score"
) %>%
  filter(analysis_time_season_week %in% 10:40) %>%
  gather_("prediction_target", "log_score",
    c("onset_log_score", "peak_week_log_score", "peak_inc_log_score")) %>%
  mutate(
    prediction_target = substr(prediction_target, 1, nchar(prediction_target) - 10),
    score = exp(log_score)
  )

preds$log_score[is.infinite(preds$log_score)] <- -15
preds <- preds %>%
  left_join(region_season_obs_quantities, by = c("region", "analysis_time_season")) %>%
  mutate(
    before_onset = (analysis_time_season_week < observed_onset_week),
    before_peak = (analysis_time_season_week < observed_peak_week))

preds$before_target_date <- ifelse(
  preds$prediction_target == "onset",
  c("on or after\ntarget date", "before\ntarget date")[preds$before_onset + 1],
  c("on or after\ntarget date", "before\ntarget date")[preds$before_peak + 1]
)

preds$model[preds$model == "kde"] <- "KDE"
preds$model[preds$model == "kcde"] <- "KCDE"
preds$model[preds$model == "sarima"] <- "SARIMA"
preds$model[preds$model == "equal_weights"] <- "EW"
preds$model[preds$model == "em_stacking"] <- "CW"
preds$model[preds$model == "xgb_stacking_unregularized"] <- "FW-wu"
preds$model[preds$model == "xgb_stacking_reg_w"] <- "FW-reg-w"
preds$model[preds$model == "xgb_stacking_reg_wu"] <- "FW-reg-wu"
preds$model[preds$model == "xgb_stacking_reg_wui"] <- "FW-reg-wui"
preds$model <- factor(preds$model,
  levels = c("KDE", "KCDE", "SARIMA",
    "EW", "CW", "FW-wu",
    "FW-reg-w", "FW-reg-wu", "FW-reg-wui"))

preds$prediction_target[preds$prediction_target == "onset"] <- "Onset Timing"
preds$prediction_target[preds$prediction_target == "peak_inc"] <- "Peak Incidence"
preds$prediction_target[preds$prediction_target == "peak_week"] <- "Peak Timing"
preds$prediction_target <- factor(preds$prediction_target,
  levels = c("Onset Timing", "Peak Timing", "Peak Incidence"))

preds <- preds %>%
  mutate(
    region = factor(region),
    analysis_time_season = factor(analysis_time_season)
  )


preds_wide <- preds %>%
#  dplyr::filter(before_target_date == "before\ntarget date") %>%
  dplyr::select(-score) %>%
  tidyr::spread(model, log_score)

registerDoMC(cores = 4)

all_models <- c("KDE", "KCDE", "SARIMA", "EW", "CW", "FW-wu", "FW-reg-w", "FW-reg-wu", "FW-reg-wui")
m_combos <- expand.grid(
  m1_ind = seq_along(all_models),
  m2_ind = seq_along(all_models)) %>%
  filter(m1_ind < m2_ind)
m_combos$m1 <- all_models[m_combos$m1_ind]
m_combos$m2 <- all_models[m_combos$m2_ind]


res <- mean(log_score ~ model + prediction_target + analysis_time_season + region,
  data = preds[preds$before_target_date == "before\ntarget date", ])
temp <- strsplit(names(res), ".", fixed = TRUE) %>%
  unlist() %>%
  matrix(ncol = 4, byrow = TRUE)
res <- cbind(temp, res) %>%
  as.data.frame(stringsAsFactors = FALSE) %>%
  `colnames<-`(c("model", "prediction_target", "season", "region", "mean_log_score")) %>%
  `rownames<-`(NULL) %>%
  group_by_(.dots = c("prediction_target", "season", "region")) %>%
  mutate(mean_log_score = as.numeric(mean_log_score),
    rank = rank(-1 * round(as.numeric(mean_log_score), 3)))

res$prediction_target <- factor(res$prediction_target,
  levels = c("Onset Timing", "Peak Timing", "Peak Incidence"))
res$model <- factor(res$model,
  levels = c("KDE", "KCDE", "SARIMA",
    "EW", "CW", "FW-wu",
    "FW-reg-w", "FW-reg-wu", "FW-reg-wui"))

res$region_season <- paste0(res$region, " - ", res$season)

median_per_target_season_region <- res %>%
  group_by(prediction_target, season, region) %>%
  summarize(median_mean_log_score = median(mean_log_score))

res2 <- res %>%
  left_join(median_per_target_season_region, by = c("prediction_target", "season", "region")) %>%
  mutate(diff_from_median = mean_log_score - median_mean_log_score)

all_models <- c("KDE", "KCDE", "SARIMA", "EW", "CW", "FW-wu", "FW-reg-w", "FW-reg-wu", "FW-reg-wui")
#all_models <- c("kde", "kcde", "sarima", "equal_weights", "em_stacking", "xgb_stacking_unregularized", "xgb_stacking_reg_w", "xgb_stacking_reg_wu", "xgb_stacking_reg_wui")

m_combos <- expand.grid(
  m1_ind = seq_along(all_models),
  m2_ind = seq_along(all_models)) %>%
  filter(m1_ind < m2_ind)
m_combos$m1 <- all_models[m_combos$m1_ind]
m_combos$m2 <- all_models[m_combos$m2_ind]

perm_test_res <- foreach(i = seq_len(nrow(m_combos))) %dopar% {
  model_pair <- m_combos[i, c("m1", "m2")]

  perm_res <- rbind.fill(lapply(seq_len(100), function(j) {
    perm_model_scores <- readRDS(
            file = paste0("~/Documents/research/epi/ensembles/adaptively-weighted-ensemble/inst/manuscript/score-permutations/perm_model_scores_season_diff_from_median_",
            model_pair[1],
            "_", model_pair[2],
            "_", j,
            ".rds"))

    lapply(perm_model_scores,
      function(comp) {
        temp <- apply(comp, 2, min)
        return(data.frame(model_1_score = unname(temp[1]),
          model_2_score = unname(temp[2]),
          model_pair = paste(names(temp), collapse = "_"),
          statistic = "min_diff_from_median"))
#        comp %>%
#          gather("model", "diff_from_median", colnames(comp)) %>%
#          group_by(model) %>%
#          summarize(p_lt_median = mean(diff_from_median < 0),
#            mean_diff_from_median = mean(diff_from_median),
#            min_diff_from_median = min(diff_from_median),
#            p10_diff_from_median = quantile(diff_from_median, 0.1)) %>%
#          gather("statistic", "value", colnames(.)[2:5]) %>%
#          mutate(model_pair = paste(colnames(comp), collapse = "_"))
      }) %>%
      rbind.fill()
  }))
}

realized_res <- res2 %>%
  group_by(model) %>%
  summarize(p_lt_median = mean(diff_from_median < 0),
    mean_diff_from_median = mean(diff_from_median),
    min_diff_from_median = min(diff_from_median),
    p10_diff_from_median = quantile(diff_from_median, 0.1)) %>%
  gather("statistic", "value", p_lt_median, mean_diff_from_median, min_diff_from_median, p10_diff_from_median) %>%
  mutate(model = as.character(model))

perm_test_c <- rbind.fill(perm_test_res)

perm_test_summaries <- perm_test_c %>%
  dplyr::mutate(
    model_pair = as.character(model_pair),
    statistic = as.character(statistic),
    perm_abs_diff = abs(model_1_score - model_2_score)) %>%
#  dplyr::mutate(perm_ind = rep(seq_len(nrow(perm_test_c)/4), each = 4),
#    model = rep(paste0("model_", c(1, 2), "_score"), times = nrow(perm_test_c)/2)) %>%
#  tidyr::spread(model, value) %>%
#  dplyr::mutate(perm_abs_diff = abs(model_1_score - model_2_score)) %>%
  dplyr::mutate(model_1 = sapply(strsplit(model_pair, "_"), function(comp) {comp[[1]]}),
    model_2 = sapply(strsplit(model_pair, "_"), function(comp) {comp[[2]]})
    ) %>%
  dplyr::left_join(realized_res, by = c("model_1" = "model", "statistic")) %>%
  dplyr::mutate(model_1_score_true = value) %>%
  dplyr::select(-value) %>%
  dplyr::left_join(realized_res, by = c("model_2" = "model", "statistic")) %>%
  dplyr::mutate(model_2_score_true = value) %>%
  dplyr::select(-value) %>%
  dplyr::mutate(realized_diff = model_1_score_true - model_2_score_true,
    realized_abs_diff = abs(model_1_score_true - model_2_score_true)) %>%
  dplyr::group_by(statistic, model_pair, model_1, model_2, realized_diff) %>%
  dplyr::summarize(abs_diff_pval = mean(perm_abs_diff >= realized_abs_diff))

realized_res <- mutate(realized_res, model = factor(model, levels = all_models))
```

```{r density_plot_diff_from_median, fig.height = 5, echo = FALSE, fig.cap="\\label{fig:density_plot_diffs_from_median}Density plots summarizing differences in mean log scores for a given method and the method with median performance for each combination of prediction target, region, and test phase season; each density curve summarizes results across all 165 combinations of 3 prediction targets, 11 regions, and 5 test phase seasons.  Positive values indicate better performance than the median model.  For legibility, we only show results for the two component models with best mean performance (KCDE and SARIMA) and for the two ensemble models with best mean performance (CW and FW-reg-w)."}
ggplot(data = res2 %>% filter(model %in% c("KCDE", "SARIMA", "FW-reg-w", "CW"))) +
  geom_density(aes(x = diff_from_median, color = model), size = 1) +
  scale_color_manual("Model", values = c("#E69F00", "#56B4E9", "#009E73", "#D55E00")) +
#  facet_wrap( ~ prediction_target, nrow = 1) +
  xlab("Difference in Mean Log Scores\nfrom Model with Median Performance") +
  theme_bw()
```


```{r min_diff_from_median_perm_test_plot, echo = FALSE, fig.height=8.5, fig.cap="\\label{fig:median_diff_pvals}For each combination of 3 prediction targets, 11 regions, and 5 test phase seasons, we calculated the difference in mean log scores between each method and the method with median performance for that target, region, and season.  Panel A presents the minimum difference from the median model for each method across all combinations of target, region, and season.  Larger values of this quantity indicate that the given model has better worst-case performance.  Panel B displays the difference in this measure of worst-case performance for each pair of models.  Positive values indicate that the model on the vertical axis had better worst-case performance than the model on the horizontal axis.  A permutation test was used to obtain approximate p-values for these differences (see supplement for details).  For reference, a Bonferroni correction at a familywise significance level of 0.05 for all pairwise comparisons leads to a significance cutoff of approximately 0.0014."}
stat_ind <- 1
stat_val <- unique(perm_test_summaries$statistic)[stat_ind]

realized_res <- res2 %>%
  group_by(model) %>%
  summarize(p_lt_median = mean(diff_from_median < 0),
    mean_diff_from_median = mean(diff_from_median),
    min_diff_from_median = min(diff_from_median),
    p10_diff_from_median = quantile(diff_from_median, 0.1),
    min_mean_log_score = min(mean_log_score)) %>%
  gather("statistic", "value", p_lt_median, mean_diff_from_median, min_diff_from_median, p10_diff_from_median, min_mean_log_score)

p_res <- ggplot(
    data = realized_res %>%
      filter(statistic == stat_val) %>%
      mutate(y = 0)) +
  geom_tile(aes(x = model, y = y, fill = value)) +
  geom_text(aes(x = model, y = y, label=format(round(value, 3), nsmall = 3)),
    size = 3) +
  scale_fill_gradient2("",
    low = "#b2182b",
    mid = "#f7f7f7",
    high = "#2166ac",
    midpoint = 0) +
  xlab("Model") +
  ylab("") +
  ggtitle("A: Minimum Difference in Log Scores from Median Method") +
#  ggtitle(stat_val) +
  theme_bw() +
  theme(axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),
    plot.margin = unit(c(5.5, 5.5, 5.5, 55.5), "pt"))

perm_test_for_plot <- perm_test_summaries %>% filter(statistic == stat_val) %>%
  ungroup() %>%
  mutate(
    model_1 = factor(model_1, levels = all_models),
    model_2 = factor(model_2, levels = all_models)
    )
perm_test_for_plot2 <- perm_test_for_plot
perm_test_for_plot2$model_1 <- perm_test_for_plot$model_2
perm_test_for_plot2$model_2 <- perm_test_for_plot$model_1
perm_test_for_plot2$realized_diff <- -1 * perm_test_for_plot$realized_diff
perm_test_for_plot_c <- rbind(perm_test_for_plot, perm_test_for_plot2)

p_pvals <- ggplot(data = perm_test_for_plot_c) +
  geom_tile(aes(x = model_2, y = model_1, fill = realized_diff)) +
  geom_text(aes(x = model_2, y = model_1, label=paste0(
    format(round(realized_diff, 3), nsmall = 3),
    "\n(",
    format(round(abs_diff_pval, 3), nsmall = 3),
    ")")),
    size = 3) +
#  geom_text(aes(x = m1, y = m2, label=paste0(pval_diff)),
#    size = 3) +
  scale_fill_gradient2("",
#    breaks = 1:9,
#    labels = as.character(1:9),
    low = "#b2182b",
    mid = "#f7f7f7",
    high = "#2166ac",
    midpoint = 0) +
  xlab("Model") +
  ylab("Model") +
  ggtitle("B: Pairwise Differences in\nMinimum Difference in Log Scores from Median Method") +
#  ggtitle(stat_val) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),
    panel.grid.minor=element_blank(),
    panel.grid.major=element_blank())

grid.newpage()
blank_height <- 0
rel_height_lower <- 1.35
pushViewport(viewport(layout =
    grid.layout(nrow = 2, ncol = 1,
      heights = unit(
        c(1, 3),
        c("null", "null")),
      widths = unit(c(1), c("null")))))
print(p_res, vp = viewport(layout.pos.row = 1, layout.pos.col = 1))
print(p_pvals, vp = viewport(layout.pos.row = 2, layout.pos.col = 1))
#pushViewport(viewport(layout =
#    grid.layout(nrow = 2, ncol = 1,
#      heights = unit(
#        c(1, 3),
#        c("null", "null")),
#      widths = unit(c(1), c("null")))))
#print(p_res, vp = viewport(layout.pos.row = 1, layout.pos.col = 1))
#print(p_pvals, vp = viewport(layout.pos.row = 2, layout.pos.col = 1))
```



\nolinenumbers

\bibliographystyle{plos2015}
\bibliography{feature-weighted-ensembles}
